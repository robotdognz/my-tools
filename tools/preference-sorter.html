<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Preference Sorter</title>
  <meta name="theme-color" content="#7c3aed">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * { -webkit-tap-highlight-color: transparent; }
    html, body, #root { height: 100%; margin: 0; overflow: hidden; }
    .allow-scroll { overflow: auto !important; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useCallback, useRef, useEffect } = React;

const MODES = {
  turbo: {
    name: 'Turbo',
    description: 'Fastest possible ranking',
    detail: 'Single-elimination tournament — finds the best quickly but less reliable for full ranking'
  },
  quick: {
    name: 'Quick',
    description: 'Fast sorting with minimal comparisons',
    detail: 'Uses a merge sort algorithm — efficient but questions are pre-determined'
  },
  smart: {
    name: 'Smart',
    description: 'Adaptive questions based on uncertainty',
    detail: 'Picks the most informative comparison each time — stops when ranking is confident'
  },
  balanced: {
    name: 'Balanced',
    description: 'Good accuracy with reasonable effort',
    detail: 'Each option compared multiple times on average'
  },
  complete: {
    name: 'Complete',
    description: 'Every option vs every other option',
    detail: 'Most accurate but requires the most comparisons'
  }
};

// Network Graph Visualization with force-directed layout
function NetworkGraph({ options, comparisonsMade, scores, compact = false, showKey = false, draggable = false }) {
  const [nodes, setNodes] = useState([]);
  const [hoveredNode, setHoveredNode] = useState(null);
  const [draggedNode, setDraggedNode] = useState(null);
  const [isPaused, setIsPaused] = useState(false);
  const frameRef = useRef(null);
  const svgRef = useRef(null);
  
  const activeOptions = compact 
    ? [...new Set(comparisonsMade.flatMap(c => [c.winner, c.loser]))]
    : options;

  const width = 320;
  const height = compact ? 200 : 320;
  const centerX = width / 2;
  const centerY = height / 2;

  const handleMouseDown = (e, nodeId) => {
    if (!draggable) return;
    e.preventDefault();
    e.stopPropagation();
    setDraggedNode(nodeId);
    setIsPaused(true);
  };

  const handleMouseMove = useCallback((e) => {
    if (!draggedNode || !svgRef.current) return;
    
    // Prevent scrolling while dragging
    e.preventDefault();
    
    const svg = svgRef.current;
    const rect = svg.getBoundingClientRect();
    const scaleX = width / rect.width;
    const scaleY = height / rect.height;
    
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    
    // Clamp to SVG bounds
    const clampedClientX = Math.max(rect.left, Math.min(rect.right, clientX));
    const clampedClientY = Math.max(rect.top, Math.min(rect.bottom, clientY));
    
    const x = (clampedClientX - rect.left) * scaleX;
    const y = (clampedClientY - rect.top) * scaleY;
    
    setNodes(prev => prev.map(n => 
      n.id === draggedNode 
        ? { ...n, x: Math.max(20, Math.min(width - 20, x)), y: Math.max(20, Math.min(height - 20, y)), vx: 0, vy: 0 }
        : n
    ));
  }, [draggedNode, width, height]);

  const handleMouseUp = useCallback(() => {
    if (draggedNode) {
      setDraggedNode(null);
      setTimeout(() => setIsPaused(false), 100);
    }
  }, [draggedNode]);

  useEffect(() => {
    if (draggable) {
      const opts = { passive: false };
      window.addEventListener('mousemove', handleMouseMove);
      window.addEventListener('mouseup', handleMouseUp);
      window.addEventListener('touchmove', handleMouseMove, opts);
      window.addEventListener('touchend', handleMouseUp);
      return () => {
        window.removeEventListener('mousemove', handleMouseMove);
        window.removeEventListener('mouseup', handleMouseUp);
        window.removeEventListener('touchmove', handleMouseMove, opts);
        window.removeEventListener('touchend', handleMouseUp);
      };
    }
  }, [draggable, handleMouseMove, handleMouseUp]);

  useEffect(() => {
    if (!activeOptions.length) {
      setNodes([]);
      return;
    }

    const rankedOptions = [...activeOptions].sort((a, b) => (scores[b] || 0) - (scores[a] || 0));
    
    const existingPositions = {};
    nodes.forEach(n => {
      existingPositions[n.id] = { x: n.x, y: n.y, vx: n.vx || 0, vy: n.vy || 0 };
    });

    const newNodes = rankedOptions.map((option, i) => {
      const existing = existingPositions[option];
      const angle = Math.random() * 2 * Math.PI;
      const dist = 30 + Math.random() * 50;
      return {
        id: option,
        x: existing?.x ?? centerX + Math.cos(angle) * dist,
        y: existing?.y ?? centerY + Math.sin(angle) * dist,
        vx: existing?.vx ?? 0,
        vy: existing?.vy ?? 0,
        rank: i + 1,
        score: scores[option] || 0
      };
    });

    const links = comparisonsMade
      .filter(c => activeOptions.includes(c.winner) && activeOptions.includes(c.loser))
      .map(c => ({ source: c.winner, target: c.loser }));

    const simulate = () => {
      const nodeMap = {};
      newNodes.forEach(n => nodeMap[n.id] = n);
      
      newNodes.forEach(node => {
        const gravityStrength = 0.02 + (1 - node.rank / newNodes.length) * 0.02;
        node.vx += (centerX - node.x) * gravityStrength;
        node.vy += (centerY - node.y) * gravityStrength;
        
        newNodes.forEach(other => {
          if (node.id === other.id) return;
          const dx = node.x - other.x;
          const dy = node.y - other.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          const minDist = compact ? 40 : 55;
          if (dist < minDist * 2) {
            const force = (minDist * 2 - dist) * 0.05;
            node.vx += (dx / dist) * force;
            node.vy += (dy / dist) * force;
          }
        });
      });

      links.forEach(link => {
        const source = nodeMap[link.source];
        const target = nodeMap[link.target];
        if (!source || !target) return;
        
        const dx = target.x - source.x;
        const dy = target.y - source.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        
        const idealDist = compact ? 50 : 70;
        const diff = dist - idealDist;
        const force = diff * 0.02;
        
        source.vx += (dx / dist) * force * 0.3;
        source.vy += (dy / dist) * force * 0.3;
        target.vx -= (dx / dist) * force * 0.7;
        target.vy -= (dy / dist) * force * 0.7;
      });

      newNodes.forEach(node => {
        node.vx *= 0.85;
        node.vy *= 0.85;
        node.x += node.vx;
        node.y += node.vy;
        
        const margin = compact ? 25 : 35;
        node.x = Math.max(margin, Math.min(width - margin, node.x));
        node.y = Math.max(margin, Math.min(height - margin, node.y));
      });

      setNodes([...newNodes]);

      const totalVelocity = newNodes.reduce((sum, n) => 
        sum + Math.abs(n.vx) + Math.abs(n.vy), 0);
      
      if (totalVelocity > 0.5 && !isPaused) {
        frameRef.current = requestAnimationFrame(simulate);
      }
    };

    if (frameRef.current) {
      cancelAnimationFrame(frameRef.current);
    }
    
    if (!isPaused) {
      frameRef.current = requestAnimationFrame(simulate);
    }

    return () => {
      if (frameRef.current) {
        cancelAnimationFrame(frameRef.current);
      }
    };
  }, [activeOptions.length, comparisonsMade.length, scores, isPaused]);

  const edges = comparisonsMade.map(({ winner, loser }) => {
    const winnerNode = nodes.find(n => n.id === winner);
    const loserNode = nodes.find(n => n.id === loser);
    if (!winnerNode || !loserNode) return null;
    return { winner, loser, winnerNode, loserNode };
  }).filter(Boolean);

  const maxScore = Math.max(...Object.values(scores), 1);
  const nodeBaseSize = compact ? 14 : 20;
  const nodeSizeRange = compact ? 8 : 12;

  const rankedForKey = [...activeOptions].sort((a, b) => (scores[b] || 0) - (scores[a] || 0));

  if (activeOptions.length === 0) {
    return (
      <div className={`flex items-center justify-center ${compact ? 'h-40' : 'h-64'} text-gray-400 text-sm`}>
        Make your first choice to see the graph
      </div>
    );
  }

  return (
    <div className={`relative ${(compact || showKey) ? 'flex gap-2' : ''}`}>
      <svg 
        ref={svgRef}
        viewBox={`0 0 ${width} ${height}`} 
        className={`${(compact || showKey) ? 'w-2/3' : 'w-full'} ${compact ? 'h-40' : 'h-64'} ${draggable ? 'cursor-grab' : ''}`}
        style={{ touchAction: 'none', ...(draggedNode ? { cursor: 'grabbing' } : {}) }}
      >
        <defs>
          <marker
            id={compact ? "arrowhead-compact" : "arrowhead"}
            markerWidth="10"
            markerHeight="7"
            refX="9"
            refY="3.5"
            orient="auto"
          >
            <polygon points="0 0, 10 3.5, 0 7" fill="#a78bfa" />
          </marker>
        </defs>
        
        {edges.map((edge, i) => {
          const dx = edge.loserNode.x - edge.winnerNode.x;
          const dy = edge.loserNode.y - edge.winnerNode.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          const winnerSize = nodeBaseSize + ((edge.winnerNode.score || 0) / maxScore) * nodeSizeRange;
          const loserSize = nodeBaseSize + ((edge.loserNode.score || 0) / maxScore) * nodeSizeRange;
          const offsetX1 = (dx / dist) * winnerSize;
          const offsetY1 = (dy / dist) * winnerSize;
          const offsetX2 = (dx / dist) * loserSize;
          const offsetY2 = (dy / dist) * loserSize;
          
          const isHighlighted = hoveredNode && 
            (edge.winner === hoveredNode || edge.loser === hoveredNode);
          const isNew = i === edges.length - 1;
          
          return (
            <line
              key={i}
              x1={edge.winnerNode.x + offsetX1}
              y1={edge.winnerNode.y + offsetY1}
              x2={edge.loserNode.x - offsetX2}
              y2={edge.loserNode.y - offsetY2}
              stroke={isNew && compact ? '#8b5cf6' : isHighlighted ? '#8b5cf6' : '#ddd6fe'}
              strokeWidth={isNew && compact ? 2 : isHighlighted ? 2 : 1}
              markerEnd={`url(#${compact ? "arrowhead-compact" : "arrowhead"})`}
              opacity={hoveredNode ? (isHighlighted ? 1 : 0.2) : (isNew && compact ? 1 : 0.6)}
            />
          );
        })}
        
        {nodes.map((node) => {
          const size = nodeBaseSize + ((node.score || 0) / maxScore) * nodeSizeRange;
          const isHovered = hoveredNode === node.id;
          const isDragging = draggedNode === node.id;
          
          return (
            <g 
              key={node.id}
              onMouseEnter={() => !draggedNode && setHoveredNode(node.id)}
              onMouseLeave={() => !draggedNode && setHoveredNode(null)}
              onMouseDown={(e) => handleMouseDown(e, node.id)}
              onTouchStart={(e) => handleMouseDown(e, node.id)}
              className={draggable ? 'cursor-grab' : 'cursor-pointer'}
              style={isDragging ? { cursor: 'grabbing' } : {}}
            >
              <circle
                cx={node.x}
                cy={node.y}
                r={size}
                fill={node.rank === 1 ? '#fbbf24' : node.rank === 2 ? '#9ca3af' : node.rank === 3 ? '#fb923c' : '#e5e7eb'}
                stroke={isDragging ? '#7c3aed' : isHovered ? '#7c3aed' : '#fff'}
                strokeWidth={isDragging ? 4 : isHovered ? 3 : 2}
              />
              <text
                x={node.x}
                y={node.y}
                textAnchor="middle"
                dominantBaseline="middle"
                fontSize={compact ? "8" : "10"}
                fontWeight="bold"
                fill={node.rank <= 3 ? '#1f2937' : '#6b7280'}
                style={{ pointerEvents: 'none' }}
              >
                {node.rank}
              </text>
            </g>
          );
        })}
      </svg>
      
      {(compact || showKey) ? (
        <div className={`w-1/3 flex flex-col justify-center text-xs space-y-1 overflow-hidden ${showKey ? 'max-h-64 overflow-y-auto' : ''}`}>
          {rankedForKey.map((option, i) => (
            <div 
              key={option} 
              className={`flex items-center gap-1.5 truncate cursor-pointer ${hoveredNode === option ? 'text-violet-700 font-medium' : 'text-gray-600'}`}
              onMouseEnter={() => setHoveredNode(option)}
              onMouseLeave={() => setHoveredNode(null)}
            >
              <span className={`w-4 h-4 flex-shrink-0 flex items-center justify-center rounded-full text-xs font-bold ${
                i === 0 ? 'bg-yellow-400 text-yellow-900' :
                i === 1 ? 'bg-gray-300 text-gray-700' :
                i === 2 ? 'bg-orange-300 text-orange-900' :
                'bg-gray-200 text-gray-600'
              }`}>
                {i + 1}
              </span>
              <span className="truncate">{option}</span>
            </div>
          ))}
          {draggable && !compact && (
            <p className="text-gray-400 text-xs mt-2 italic">Drag nodes to rearrange</p>
          )}
        </div>
      ) : (
        <div className="text-center mt-2 h-6">
          {hoveredNode ? (
            <span className="text-sm text-violet-700 font-medium">{hoveredNode}</span>
          ) : (
            <span className="text-xs text-gray-400">Hover over nodes to see details</span>
          )}
        </div>
      )}
    </div>
  );
}

function MatchupMatrix({ options, comparisonsMade, scores }) {
  const rankedOptions = [...options].sort((a, b) => scores[b] - scores[a]);
  
  const matchups = {};
  comparisonsMade.forEach(({ winner, loser }) => {
    matchups[`${winner}|${loser}`] = 'win';
    matchups[`${loser}|${winner}`] = 'loss';
  });

  const getResult = (row, col) => {
    if (row === col) return 'self';
    return matchups[`${row}|${col}`] || 'none';
  };

  const truncate = (str, len = 8) => 
    str.length > len ? str.slice(0, len) + '…' : str;

  return (
    <div className="overflow-x-auto">
      <table className="w-full text-xs">
        <thead>
          <tr>
            <th className="p-1"></th>
            {rankedOptions.map((opt, i) => (
              <th key={opt} className="p-1 font-medium text-gray-500 truncate max-w-[60px]" title={opt}>
                {i + 1}
              </th>
            ))}
          </tr>
        </thead>
        <tbody>
          {rankedOptions.map((rowOpt) => (
            <tr key={rowOpt}>
              <td className="p-1 font-medium text-gray-700 truncate max-w-[80px]" title={rowOpt}>
                {truncate(rowOpt)}
              </td>
              {rankedOptions.map((colOpt) => {
                const result = getResult(rowOpt, colOpt);
                return (
                  <td 
                    key={colOpt}
                    className={`p-1 w-8 h-8 text-center ${
                      result === 'self' ? 'bg-gray-100' :
                      result === 'win' ? 'bg-green-100 text-green-700' :
                      result === 'loss' ? 'bg-red-100 text-red-700' :
                      'bg-gray-50 text-gray-300'
                    }`}
                  >
                    {result === 'self' ? '—' : result === 'win' ? 'W' : result === 'loss' ? 'L' : '·'}
                  </td>
                );
              })}
            </tr>
          ))}
        </tbody>
      </table>
      <div className="flex justify-center gap-4 mt-3 text-xs text-gray-500">
        <span><span className="inline-block w-3 h-3 bg-green-100 mr-1 rounded"></span>Win</span>
        <span><span className="inline-block w-3 h-3 bg-red-100 mr-1 rounded"></span>Loss</span>
        <span><span className="inline-block w-3 h-3 bg-gray-50 mr-1 rounded border"></span>Not compared</span>
      </div>
    </div>
  );
}

function StrengthChart({ options, scores }) {
  const rankedOptions = [...options].sort((a, b) => scores[b] - scores[a]);
  const maxScore = Math.max(...Object.values(scores), 1);

  return (
    <div className="space-y-2">
      {rankedOptions.map((option, index) => {
        const percentage = (scores[option] / maxScore) * 100;
        return (
          <div key={option} className="flex items-center gap-2">
            <span className={`w-6 h-6 flex items-center justify-center rounded-full text-xs font-bold ${
              index === 0 ? 'bg-yellow-400 text-yellow-900' :
              index === 1 ? 'bg-gray-300 text-gray-700' :
              index === 2 ? 'bg-orange-300 text-orange-900' :
              'bg-gray-200 text-gray-600'
            }`}>
              {index + 1}
            </span>
            <div className="flex-1">
              <div className="flex justify-between mb-1">
                <span className="text-sm font-medium text-gray-700 truncate" title={option}>
                  {option}
                </span>
                <span className="text-xs text-gray-500">{scores[option]} wins</span>
              </div>
              <div className="w-full bg-gray-200 rounded-full h-2">
                <div 
                  className={`h-2 rounded-full transition-all duration-500 ${
                    index === 0 ? 'bg-yellow-400' :
                    index === 1 ? 'bg-gray-400' :
                    index === 2 ? 'bg-orange-400' :
                    'bg-violet-400'
                  }`}
                  style={{ width: `${Math.max(percentage, 5)}%` }}
                />
              </div>
            </div>
          </div>
        );
      })}
    </div>
  );
}

function ResultsView({ comparisonsMade, mode, scores, options, reset }) {
  const [activeTab, setActiveTab] = useState('network');
  
  const tabs = [
    { id: 'network', label: 'Network' },
    { id: 'ranking', label: 'Ranking' },
    { id: 'matrix', label: 'Matchups' },
  ];

  return (
    <div className="bg-white rounded-2xl shadow-xl p-8">
      <h2 className="text-2xl font-bold text-gray-800 mb-2">Your Rankings</h2>
      <p className="text-gray-500 mb-4">
        Based on {comparisonsMade.length} comparisons
        <span className="text-gray-400 ml-1">({MODES[mode].name} mode)</span>
      </p>

      <div className="flex gap-1 mb-6 bg-gray-100 p-1 rounded-lg">
        {tabs.map(tab => (
          <button
            key={tab.id}
            onClick={() => setActiveTab(tab.id)}
            className={`flex-1 py-2 px-3 text-sm font-medium rounded-md transition-all ${
              activeTab === tab.id 
                ? 'bg-white text-violet-700 shadow-sm' 
                : 'text-gray-600 hover:text-gray-800'
            }`}
          >
            {tab.label}
          </button>
        ))}
      </div>

      <div className="min-h-[280px]">
        {activeTab === 'ranking' && (
          <StrengthChart options={options} scores={scores} />
        )}
        
        {activeTab === 'network' && (
          <NetworkGraph 
            options={options} 
            comparisonsMade={comparisonsMade}
            scores={scores}
            showKey={true}
            draggable={true}
          />
        )}
        
        {activeTab === 'matrix' && (
          <MatchupMatrix 
            options={options}
            comparisonsMade={comparisonsMade}
            scores={scores}
          />
        )}
      </div>

      <button
        onClick={reset}
        className="w-full mt-6 py-3 bg-violet-600 hover:bg-violet-700 text-white font-semibold rounded-xl transition-colors"
      >
        Start Over
      </button>
    </div>
  );
}

function App() {
  const [stage, setStage] = useState('input');
  const [inputText, setInputText] = useState('');
  const [mode, setMode] = useState('smart');
  const [options, setOptions] = useState([]);
  const [scores, setScores] = useState({});
  const [comparisons, setComparisons] = useState([]);
  const [currentComparison, setCurrentComparison] = useState(0);
  const [comparisonsMade, setComparisonsMade] = useState([]);
  const [totalEstimate, setTotalEstimate] = useState(0);
  const [showModeInfo, setShowModeInfo] = useState(false);
  const [showAdvancedModes, setShowAdvancedModes] = useState(false);
  
  const mergeSortState = useRef(null);
  const tournamentState = useRef(null);
  const smartState = useRef(null);
  const [smartExplanation, setSmartExplanation] = useState('');
  const [smartEstimatedLeft, setSmartEstimatedLeft] = useState(0);

  const shuffle = (array) => {
    const arr = [...array];
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  };

  const generateCompleteComparisons = (items) => {
    const pairs = [];
    for (let i = 0; i < items.length; i++) {
      for (let j = i + 1; j < items.length; j++) {
        pairs.push([items[i], items[j]]);
      }
    }
    return shuffle(pairs);
  };

  const generateBalancedComparisons = (items) => {
    const n = items.length;
    const complete = (n * (n - 1)) / 2;
    const targetComparisons = Math.max(Math.floor(n * 1.5), Math.floor(complete * 0.6));
    const maxComparisons = Math.min(targetComparisons, complete - 1);
    
    const pairs = new Set();
    const shuffled = shuffle(items);
    
    while (pairs.size < maxComparisons) {
      const available = shuffle([...shuffled]);
      const paired = new Set();
      const startSize = pairs.size;
      
      while (available.length >= 2 && pairs.size < maxComparisons) {
        const a = available.shift();
        if (paired.has(a)) continue;
        
        let matchIdx = available.findIndex(b => 
          !paired.has(b) && !pairs.has(`${a}|${b}`) && !pairs.has(`${b}|${a}`)
        );
        
        if (matchIdx === -1) break;
        
        const b = available.splice(matchIdx, 1)[0];
        pairs.add([a, b].sort().join('|'));
        paired.add(a);
        paired.add(b);
      }
      
      if (pairs.size === startSize) break;
    }
    
    return shuffle(Array.from(pairs).map(p => p.split('|')));
  };

  const initMergeSort = (items) => {
    const shuffled = shuffle(items);
    mergeSortState.current = {
      items: shuffled, sorted: [], left: [], right: [],
      leftIdx: 0, rightIdx: 0, stack: shuffled.map(item => [item]), phase: 'merging'
    };
    return getNextMergePair();
  };

  const getNextMergePair = () => {
    const state = mergeSortState.current;
    if (!state) return null;
    
    if (state.left.length === 0 && state.right.length === 0) {
      if (state.stack.length < 2) {
        state.sorted = state.stack[0] || [];
        return null;
      }
      state.left = state.stack.shift();
      state.right = state.stack.shift();
      state.leftIdx = 0;
      state.rightIdx = 0;
      state.merged = [];
    }
    
    if (state.leftIdx >= state.left.length) {
      state.merged.push(...state.right.slice(state.rightIdx));
      state.stack.push(state.merged);
      state.left = [];
      state.right = [];
      return getNextMergePair();
    }
    
    if (state.rightIdx >= state.right.length) {
      state.merged.push(...state.left.slice(state.leftIdx));
      state.stack.push(state.merged);
      state.left = [];
      state.right = [];
      return getNextMergePair();
    }
    
    return [state.left[state.leftIdx], state.right[state.rightIdx]];
  };

  const handleMergeSortChoice = (winner) => {
    const state = mergeSortState.current;
    if (winner === state.left[state.leftIdx]) {
      state.merged.push(state.left[state.leftIdx]);
      state.leftIdx++;
    } else {
      state.merged.push(state.right[state.rightIdx]);
      state.rightIdx++;
    }
    return getNextMergePair();
  };

  const initTournament = (items) => {
    const shuffled = shuffle(items);
    tournamentState.current = { remaining: [...shuffled], eliminated: [], currentRound: [], ranking: [] };
    return getNextTournamentPair();
  };

  const getNextTournamentPair = () => {
    const state = tournamentState.current;
    if (!state) return null;
    
    if (state.currentRound.length >= 2) return [state.currentRound[0], state.currentRound[1]];
    if (state.remaining.length === 1) {
      state.ranking = [state.remaining[0], ...state.eliminated.reverse()];
      return null;
    }
    if (state.remaining.length === 0) {
      state.ranking = [...state.eliminated.reverse()];
      return null;
    }
    if (state.remaining.length >= 2) {
      state.currentRound = [state.remaining.shift(), state.remaining.shift()];
      return [state.currentRound[0], state.currentRound[1]];
    }
    return null;
  };

  const handleTournamentChoice = (winner) => {
    const state = tournamentState.current;
    const loser = state.currentRound.find(x => x !== winner);
    state.remaining.push(winner);
    state.eliminated.push(loser);
    state.currentRound = [];
    return getNextTournamentPair();
  };

  const initSmart = (items) => {
    smartState.current = { items: [...items], wins: {}, compared: new Set() };
    items.forEach(item => { smartState.current.wins[item] = {}; });
    setSmartEstimatedLeft(Math.ceil(items.length * Math.log2(items.length)));
    return getNextSmartPair();
  };

  const getWinProbability = (a, b, wins, items) => {
    if (wins[a]?.[b]) return 1;
    if (wins[b]?.[a]) return 0;
    
    let aAdvantage = 0;
    items.forEach(other => {
      if (other === a || other === b) return;
      if (wins[a]?.[other] && wins[other]?.[b]) aAdvantage += 0.5;
      if (wins[b]?.[other] && wins[other]?.[a]) aAdvantage -= 0.5;
      if (wins[a]?.[other]) aAdvantage += 0.1;
      if (wins[b]?.[other]) aAdvantage -= 0.1;
    });
    
    return 0.5 + Math.max(-0.4, Math.min(0.4, aAdvantage * 0.2));
  };

  const getComparisonValue = (a, b, wins, items) => {
    const p = getWinProbability(a, b, wins, items);
    if (p <= 0 || p >= 1) return 0;
    return -p * Math.log2(p) - (1 - p) * Math.log2(1 - p);
  };

  const getQuestionExplanation = (a, b, wins, items) => {
    const p = getWinProbability(a, b, wins, items);
    const aWins = Object.keys(wins[a] || {}).length;
    const bWins = Object.keys(wins[b] || {}).length;
    const aTransitive = items.filter(x => wins[a]?.[x] && wins[x]?.[b]);
    const bTransitive = items.filter(x => wins[b]?.[x] && wins[x]?.[a]);
    
    if (aWins === 0 && bWins === 0) return "First time seeing both — need direct comparison";
    if (aWins === 0) return `Introducing "${a}" against established option`;
    if (bWins === 0) return `Introducing "${b}" against established option`;
    if (Math.abs(p - 0.5) < 0.1) return "These are very close — this will help break the tie";
    if (aTransitive.length > 0 || bTransitive.length > 0) return "Verifying transitive assumption";
    if (Math.abs(aWins - bWins) <= 1) return "Similar win counts — determining relative ranking";
    return "Filling in comparison data for confidence";
  };

  const estimateRemainingQuestions = (wins, items, compared) => {
    let uncertainPairs = 0;
    for (let i = 0; i < items.length; i++) {
      for (let j = i + 1; j < items.length; j++) {
        const key = [items[i], items[j]].sort().join('|');
        if (compared.has(key)) continue;
        const p = getWinProbability(items[i], items[j], wins, items);
        if (Math.abs(p - 0.5) < 0.35) uncertainPairs++;
      }
    }
    return Math.min(uncertainPairs, Math.ceil(items.length * 0.8));
  };

  const isRankingConfident = (wins, items) => {
    const ranked = [...items].sort((a, b) => 
      Object.keys(wins[b] || {}).length - Object.keys(wins[a] || {}).length
    );
    
    for (let i = 0; i < ranked.length - 1; i++) {
      if (!wins[ranked[i]]?.[ranked[i + 1]]) {
        if (getWinProbability(ranked[i], ranked[i + 1], wins, items) < 0.7) return false;
      }
    }
    return true;
  };

  const getNextSmartPair = () => {
    const state = smartState.current;
    if (!state) return null;
    
    const { items, wins, compared } = state;
    
    if (compared.size >= items.length && isRankingConfident(wins, items)) {
      setSmartExplanation('');
      setSmartEstimatedLeft(0);
      return null;
    }
    
    let bestPair = null;
    let bestValue = -1;
    
    for (let i = 0; i < items.length; i++) {
      for (let j = i + 1; j < items.length; j++) {
        const key = [items[i], items[j]].sort().join('|');
        if (compared.has(key)) continue;
        const value = getComparisonValue(items[i], items[j], wins, items);
        if (value > bestValue) {
          bestValue = value;
          bestPair = [items[i], items[j]];
        }
      }
    }
    
    if (!bestPair || bestValue < 0.1) {
      setSmartExplanation('');
      setSmartEstimatedLeft(0);
      return null;
    }
    
    setSmartExplanation(getQuestionExplanation(bestPair[0], bestPair[1], wins, items));
    setSmartEstimatedLeft(estimateRemainingQuestions(wins, items, compared));
    
    return Math.random() > 0.5 ? bestPair : [bestPair[1], bestPair[0]];
  };

  const handleSmartChoice = (winner, loser) => {
    const state = smartState.current;
    state.wins[winner][loser] = true;
    state.compared.add([winner, loser].sort().join('|'));
    return getNextSmartPair();
  };

  const getSmartRanking = () => {
    const state = smartState.current;
    if (!state) return [];
    const { items, wins } = state;
    
    return [...items].sort((a, b) => {
      const aWins = Object.keys(wins[a] || {}).length;
      const bWins = Object.keys(wins[b] || {}).length;
      if (bWins !== aWins) return bWins - aWins;
      
      const aStrength = Object.keys(wins[a] || {}).reduce((sum, d) => 
        sum + Object.keys(wins[d] || {}).length, 0);
      const bStrength = Object.keys(wins[b] || {}).reduce((sum, d) => 
        sum + Object.keys(wins[d] || {}).length, 0);
      return bStrength - aStrength;
    });
  };

  const estimateComparisons = (n, selectedMode) => {
    if (selectedMode === 'complete') return (n * (n - 1)) / 2;
    if (selectedMode === 'balanced') {
      const complete = (n * (n - 1)) / 2;
      return Math.min(Math.max(Math.floor(n * 1.5), Math.floor(complete * 0.6)), complete - 1);
    }
    if (selectedMode === 'smart') return Math.ceil(n * Math.log2(n) * 1.2) + '?';
    if (selectedMode === 'quick') return Math.ceil(n * Math.log2(n));
    return n - 1;
  };

  const startComparing = () => {
    const items = inputText.split('\n').map(s => s.trim()).filter(s => s.length > 0);
    
    if (items.length < 2) {
      alert('Please enter at least 2 options');
      return;
    }

    const initialScores = {};
    items.forEach(item => { initialScores[item] = 0; });

    setOptions(items);
    setScores(initialScores);
    setCurrentComparison(0);
    setComparisonsMade([]);
    setTotalEstimate(estimateComparisons(items.length, mode));

    if (mode === 'turbo') {
      const firstPair = initTournament(items);
      if (firstPair) { setComparisons([firstPair]); setStage('comparing'); }
    } else if (mode === 'quick') {
      const firstPair = initMergeSort(items);
      if (firstPair) { setComparisons([firstPair]); setStage('comparing'); }
    } else if (mode === 'smart') {
      const firstPair = initSmart(items);
      if (firstPair) { setComparisons([firstPair]); setStage('comparing'); }
    } else {
      const pairs = mode === 'complete' ? generateCompleteComparisons(items) : generateBalancedComparisons(items);
      setComparisons(pairs);
      setStage('comparing');
    }
  };

  const handleChoice = (winner, loser) => {
    const newScores = { ...scores };
    newScores[winner] = (newScores[winner] || 0) + 1;
    setScores(newScores);
    
    setComparisonsMade(prev => [...prev, { winner, loser }]);

    if (mode === 'turbo') {
      const nextPair = handleTournamentChoice(winner);
      if (nextPair) setComparisons([nextPair]);
      else { setOptions(tournamentState.current.ranking); setStage('result'); }
    } else if (mode === 'quick') {
      const nextPair = handleMergeSortChoice(winner);
      if (nextPair) setComparisons([nextPair]);
      else { setOptions(mergeSortState.current.sorted); setStage('result'); }
    } else if (mode === 'smart') {
      const nextPair = handleSmartChoice(winner, loser);
      if (nextPair) setComparisons([nextPair]);
      else { setOptions(getSmartRanking()); setStage('result'); }
    } else {
      if (currentComparison + 1 >= comparisons.length) setStage('result');
      else setCurrentComparison(currentComparison + 1);
    }
  };

  const reset = () => {
    setStage('input');
    setInputText('');
    setOptions([]);
    setScores({});
    setComparisons([]);
    setCurrentComparison(0);
    setComparisonsMade([]);
    mergeSortState.current = null;
    tournamentState.current = null;
    smartState.current = null;
  };

  const progress = totalEstimate > 0 && typeof totalEstimate === 'number'
    ? Math.min(Math.round((comparisonsMade.length / totalEstimate) * 100), 99) : 0;

  const currentPair = (mode === 'quick' || mode === 'turbo' || mode === 'smart') 
    ? comparisons[0] : comparisons[currentComparison];

  const getButtonOrder = (pair) => {
    if (!pair) return pair;
    const hash = pair[0].length + pair[1].length + pair[0].charCodeAt(0);
    return hash % 2 === 0 ? pair : [pair[1], pair[0]];
  };

  const itemCount = inputText.split('\n').filter(s => s.trim().length > 0).length;

  return (
    <div className="h-full bg-gradient-to-br from-violet-50 to-indigo-100 p-4 flex items-center justify-center overflow-auto">
      <div className="w-full max-w-xl my-auto">
        
        {stage === 'input' && (
          <div className="bg-white rounded-2xl shadow-xl p-6">
            <h1 className="text-2xl font-bold text-gray-800 mb-2">Preference Sorter</h1>
            <p className="text-gray-500 mb-4 text-sm">Enter your options below, one per line.</p>
            
            <textarea
              value={inputText}
              onChange={(e) => setInputText(e.target.value)}
              placeholder={"Pizza\nSushi\nTacos\nBurgers\nPasta"}
              className="w-full h-36 p-4 border border-gray-200 rounded-xl text-gray-700 placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-violet-400 resize-none"
            />

            <div className="mt-4 mb-4">
              <div className="flex items-center justify-between mb-2">
                <label className="text-sm font-medium text-gray-700">Mode</label>
                <button
                  onClick={() => setShowModeInfo(!showModeInfo)}
                  className="text-xs text-violet-600"
                >
                  {showModeInfo ? 'Hide info' : 'How does it work?'}
                </button>
              </div>
              
              {showModeInfo && (
                <div className="mb-3 p-3 bg-violet-50 rounded-xl text-xs text-gray-600">
                  <strong className="text-violet-700">Smart</strong> picks the most informative question each time, uses transitive logic to skip obvious comparisons, and stops when confident.
                </div>
              )}
              
              <div className="space-y-2">
                {Object.entries(MODES)
                  .filter(([key]) => ['smart'].includes(key))
                  .map(([key, { name, description, detail }]) => {
                    const est = itemCount >= 2 ? estimateComparisons(itemCount, key) : 0;
                    return (
                      <button
                        key={key}
                        onClick={() => setMode(key)}
                        className={`w-full p-3 rounded-xl border-2 text-left ${
                          mode === key ? 'border-violet-500 bg-violet-50' : 'border-gray-200'
                        }`}
                      >
                        <div className="flex items-center justify-between">
                          <span className={`font-semibold ${mode === key ? 'text-violet-700' : 'text-gray-800'}`}>
                            {name}
                          </span>
                          <span className="text-sm text-gray-400">
                            {itemCount >= 2 ? `~${est} questions` : '—'}
                          </span>
                        </div>
                        <p className="text-xs text-gray-400 mt-1">{detail}</p>
                      </button>
                    );
                  })}
              </div>
              
              <button
                onClick={() => setShowAdvancedModes(!showAdvancedModes)}
                className="w-full mt-2 py-2 text-sm text-gray-500 flex items-center justify-center gap-1"
              >
                {showAdvancedModes ? 'Hide' : 'Show'} other modes
                <svg className={`w-4 h-4 transition-transform ${showAdvancedModes ? 'rotate-180' : ''}`} fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                </svg>
              </button>
              
              {showAdvancedModes && (
                <div className="space-y-2 mt-2">
                  {Object.entries(MODES)
                    .filter(([key]) => ['turbo', 'quick', 'balanced', 'complete'].includes(key))
                    .map(([key, { name, detail }]) => {
                      const est = itemCount >= 2 ? estimateComparisons(itemCount, key) : 0;
                      return (
                        <button
                          key={key}
                          onClick={() => setMode(key)}
                          className={`w-full p-3 rounded-xl border-2 text-left ${
                            mode === key ? 'border-violet-500 bg-violet-50' : 'border-gray-200'
                          }`}
                        >
                          <div className="flex items-center justify-between">
                            <span className={`font-semibold ${mode === key ? 'text-violet-700' : 'text-gray-800'}`}>{name}</span>
                            <span className="text-sm text-gray-400">{itemCount >= 2 ? `~${est}` : '—'}</span>
                          </div>
                          <p className="text-xs text-gray-400 mt-1">{detail}</p>
                        </button>
                      );
                    })}
                </div>
              )}
            </div>
            
            <button
              onClick={startComparing}
              className="w-full py-3 bg-violet-600 hover:bg-violet-700 text-white font-semibold rounded-xl"
            >
              Start Comparing
            </button>
          </div>
        )}

        {stage === 'comparing' && currentPair && (
          <div className="bg-white rounded-2xl shadow-xl p-6">
            <div className="text-center mb-3">
              <p className="text-sm text-gray-500 mb-2">
                Question {comparisonsMade.length + 1}
                {mode === 'smart' && smartEstimatedLeft > 0 && (
                  <span className="text-violet-600 ml-2">~{smartEstimatedLeft} left</span>
                )}
              </p>
              <div className="w-full bg-gray-200 rounded-full h-2">
                <div 
                  className="bg-violet-600 h-2 rounded-full transition-all"
                  style={{ width: `${Math.min(progress, 95)}%` }}
                />
              </div>
            </div>

            {comparisonsMade.length > 0 && (
              <div className="mb-3 -mx-2">
                <NetworkGraph 
                  options={options} 
                  comparisonsMade={comparisonsMade}
                  scores={scores}
                  compact={true}
                  draggable={true}
                />
              </div>
            )}

            <h2 className="text-lg font-semibold text-gray-800 text-center mb-1">
              Which do you prefer?
            </h2>
            
            {mode === 'smart' && smartExplanation && (
              <p className="text-xs text-gray-400 text-center mb-3 italic">{smartExplanation}</p>
            )}

            <div className="space-y-2">
              {getButtonOrder(currentPair).map((option, idx) => (
                <button
                  key={option + idx}
                  onClick={() => handleChoice(option, currentPair.find(o => o !== option))}
                  className="w-full p-4 text-lg font-medium text-gray-700 bg-gray-50 hover:bg-violet-100 hover:text-violet-700 border-2 border-gray-200 hover:border-violet-400 rounded-xl transition-all"
                >
                  {option}
                </button>
              ))}
            </div>
          </div>
        )}

        {stage === 'result' && (
          <ResultsView 
            comparisonsMade={comparisonsMade}
            mode={mode}
            scores={scores}
            options={options}
            reset={reset}
          />
        )}
      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
