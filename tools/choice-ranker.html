<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Choice Ranker</title>
  <meta name="theme-color" content="#7c3aed">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
  <script src="../shared/share-card.js"></script>
  <style>
    * { -webkit-tap-highlight-color: transparent; }
    html, body, #root { height: 100%; margin: 0; overflow: hidden; }
    .allow-scroll { overflow: auto !important; }

    @keyframes confetti-fall {
      0% { transform: translateY(-100%) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }
    .confetti {
      position: fixed;
      width: 10px;
      height: 10px;
      top: -10px;
      animation: confetti-fall 3s ease-out forwards;
      z-index: 1000;
      pointer-events: none;
    }

    /* Node pop-in animation */
    @keyframes node-pop {
      0% { transform: scale(0); opacity: 0; }
      50% { transform: scale(1.3); }
      100% { transform: scale(1); opacity: 1; }
    }
    .node-pop {
      animation: node-pop 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    }

    /* Gentle floating animation */
    @keyframes float {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-3px); }
    }
    .node-float {
      animation: float 3s ease-in-out infinite;
    }

    /* Pulsing glow for compared nodes */
    @keyframes pulse-glow {
      0%, 100% { filter: drop-shadow(0 0 4px rgba(139, 92, 246, 0.6)); }
      50% { filter: drop-shadow(0 0 12px rgba(139, 92, 246, 0.9)); }
    }
    .node-comparing {
      animation: pulse-glow 1s ease-in-out infinite;
    }

    /* Arrow shoot animation */
    @keyframes arrow-shoot {
      0% { stroke-dashoffset: 100; opacity: 0; }
      30% { opacity: 1; }
      100% { stroke-dashoffset: 0; opacity: 1; }
    }
    .arrow-new {
      stroke-dasharray: 100;
      animation: arrow-shoot 0.5s ease-out forwards;
    }

    /* Arrow pulse for recent connections */
    @keyframes arrow-pulse {
      0% { stroke-width: 2; }
      50% { stroke-width: 4; }
      100% { stroke-width: 2; }
    }
    .arrow-pulse {
      animation: arrow-pulse 0.3s ease-out;
    }


    /* Top rank glow effect */
    @keyframes top-glow {
      0%, 100% { filter: drop-shadow(0 0 6px rgba(251, 191, 36, 0.5)); }
      50% { filter: drop-shadow(0 0 12px rgba(251, 191, 36, 0.8)); }
    }
    .top-rank-glow {
      animation: top-glow 2s ease-in-out infinite;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useCallback, useRef, useEffect } = React;

// Confetti component
function Confetti({ show }) {
  const [pieces, setPieces] = useState([]);

  useEffect(() => {
    if (show) {
      const colors = ['#7c3aed', '#06b6d4', '#f59e0b', '#10b981', '#ef4444', '#ec4899'];
      const newPieces = Array.from({ length: 50 }, (_, i) => ({
        id: i,
        left: Math.random() * 100,
        delay: Math.random() * 0.5,
        color: colors[Math.floor(Math.random() * colors.length)],
        size: 6 + Math.random() * 8,
      }));
      setPieces(newPieces);
      const timer = setTimeout(() => setPieces([]), 3500);
      return () => clearTimeout(timer);
    }
  }, [show]);

  if (!show || pieces.length === 0) return null;

  return (
    <>
      {pieces.map(piece => (
        <div
          key={piece.id}
          className="confetti"
          style={{
            left: `${piece.left}%`,
            backgroundColor: piece.color,
            width: piece.size,
            height: piece.size,
            animationDelay: `${piece.delay}s`,
            borderRadius: Math.random() > 0.5 ? '50%' : '0',
          }}
        />
      ))}
    </>
  );
}

// Algorithm mode is always 'smart'

// Network Graph Visualization with force-directed layout
function NetworkGraph({
  options,
  comparisonsMade = [],
  scores = {},
  compact = false,
  showKey = false,
  draggable = false,
  inputMode = false,           // Show minimal nodes during input phase
  comparingPair = null,        // [optionA, optionB] currently being compared
  onNodeClick = null,          // Callback when node is clicked (for sync)
  selectedNode = null,         // Node highlighted from external selection
  isResultsView = false,       // Enable results reveal animation
}) {
  const [nodes, setNodes] = useState([]);
  const [draggedNode, setDraggedNode] = useState(null);
  const [isPaused, setIsPaused] = useState(false);
  const [newArrowIndex, setNewArrowIndex] = useState(-1);
  const [revealedNodes, setRevealedNodes] = useState(new Set());
  const frameRef = useRef(null);
  const svgRef = useRef(null);
  const prevComparisonCount = useRef(0);
  const prevOptionsRef = useRef([]);

  const activeOptions = options;

  const width = 320;
  const height = compact ? 200 : (inputMode ? 180 : 320);
  const centerX = width / 2;
  const centerY = height / 2;

  // Track new arrows for animation
  useEffect(() => {
    if (comparisonsMade.length > prevComparisonCount.current) {
      setNewArrowIndex(comparisonsMade.length - 1);
      const timer = setTimeout(() => setNewArrowIndex(-1), 500);
      prevComparisonCount.current = comparisonsMade.length;
      return () => clearTimeout(timer);
    }
  }, [comparisonsMade.length]);

  // Track new nodes for pop animation
  const newNodes = useRef(new Set());
  useEffect(() => {
    const prevOptions = new Set(prevOptionsRef.current);
    options.forEach(opt => {
      if (!prevOptions.has(opt)) {
        newNodes.current.add(opt);
        setTimeout(() => newNodes.current.delete(opt), 400);
      }
    });
    prevOptionsRef.current = [...options];
  }, [options]);

  // Results reveal animation - just set all as revealed immediately
  // (the confetti and other animations handle the celebration)
  useEffect(() => {
    if (isResultsView && options.length > 0) {
      setRevealedNodes(new Set(options));
    }
  }, [isResultsView, options]);

  const handleMouseDown = (e, nodeId) => {
    if (!draggable) return;
    e.preventDefault();
    e.stopPropagation();
    setDraggedNode(nodeId);
    setIsPaused(true);
  };

  const handleMouseMove = useCallback((e) => {
    if (!draggedNode || !svgRef.current) return;
    
    // Prevent scrolling while dragging
    e.preventDefault();
    
    const svg = svgRef.current;
    const rect = svg.getBoundingClientRect();
    const scaleX = width / rect.width;
    const scaleY = height / rect.height;
    
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    
    // Clamp to SVG bounds
    const clampedClientX = Math.max(rect.left, Math.min(rect.right, clientX));
    const clampedClientY = Math.max(rect.top, Math.min(rect.bottom, clientY));
    
    const x = (clampedClientX - rect.left) * scaleX;
    const y = (clampedClientY - rect.top) * scaleY;
    
    setNodes(prev => prev.map(n =>
      n.id === draggedNode
        ? { ...n, x: Math.max(20, Math.min(width - 20, x)), y: Math.max(20, Math.min(height - 20, y)), vx: 0, vy: 0 }
        : n
    ));
  }, [draggedNode, width, height]);

  const handleMouseUp = useCallback(() => {
    if (draggedNode) {
      setDraggedNode(null);
      setTimeout(() => setIsPaused(false), 100);
    }
  }, [draggedNode]);

  useEffect(() => {
    if (draggable) {
      const opts = { passive: false };
      window.addEventListener('mousemove', handleMouseMove);
      window.addEventListener('mouseup', handleMouseUp);
      window.addEventListener('touchmove', handleMouseMove, opts);
      window.addEventListener('touchend', handleMouseUp);
      return () => {
        window.removeEventListener('mousemove', handleMouseMove);
        window.removeEventListener('mouseup', handleMouseUp);
        window.removeEventListener('touchmove', handleMouseMove, opts);
        window.removeEventListener('touchend', handleMouseUp);
      };
    }
  }, [draggable, handleMouseMove, handleMouseUp]);

  useEffect(() => {
    if (!activeOptions.length) {
      setNodes([]);
      return;
    }

    const rankedOptions = [...activeOptions].sort((a, b) => (scores[b] || 0) - (scores[a] || 0));

    const existingPositions = {};
    nodes.forEach(n => {
      existingPositions[n.id] = { x: n.x, y: n.y, vx: n.vx || 0, vy: n.vy || 0 };
    });

    const newNodes = rankedOptions.map((option, i) => {
      const existing = existingPositions[option];
      const angle = Math.random() * 2 * Math.PI;
      const dist = 30 + Math.random() * 50;
      return {
        id: option,
        x: existing?.x ?? centerX + Math.cos(angle) * dist,
        y: existing?.y ?? centerY + Math.sin(angle) * dist,
        vx: existing?.vx ?? 0,
        vy: existing?.vy ?? 0,
        rank: i + 1,
        score: scores[option] || 0
      };
    });

    const links = comparisonsMade
      .filter(c => activeOptions.includes(c.winner) && activeOptions.includes(c.loser))
      .map(c => ({ source: c.winner, target: c.loser }));

    const simulate = () => {
      const nodeMap = {};
      newNodes.forEach(n => nodeMap[n.id] = n);

      newNodes.forEach(node => {
        const gravityStrength = 0.02 + (1 - node.rank / newNodes.length) * 0.02;
        node.vx += (centerX - node.x) * gravityStrength;
        node.vy += (centerY - node.y) * gravityStrength;

        newNodes.forEach(other => {
          if (node.id === other.id) return;
          const dx = node.x - other.x;
          const dy = node.y - other.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          const minDist = compact ? 40 : 55;
          if (dist < minDist * 2) {
            const force = (minDist * 2 - dist) * 0.05;
            node.vx += (dx / dist) * force;
            node.vy += (dy / dist) * force;
          }
        });
      });

      links.forEach(link => {
        const source = nodeMap[link.source];
        const target = nodeMap[link.target];
        if (!source || !target) return;

        const dx = target.x - source.x;
        const dy = target.y - source.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;

        const idealDist = compact ? 50 : 70;
        const diff = dist - idealDist;
        const force = diff * 0.02;

        source.vx += (dx / dist) * force * 0.3;
        source.vy += (dy / dist) * force * 0.3;
        target.vx -= (dx / dist) * force * 0.7;
        target.vy -= (dy / dist) * force * 0.7;
      });

      newNodes.forEach(node => {
        node.vx *= 0.85;
        node.vy *= 0.85;
        node.x += node.vx;
        node.y += node.vy;

        const margin = compact ? 25 : 35;
        node.x = Math.max(margin, Math.min(width - margin, node.x));
        node.y = Math.max(margin, Math.min(height - margin, node.y));
      });

      setNodes([...newNodes]);

      const totalVelocity = newNodes.reduce((sum, n) =>
        sum + Math.abs(n.vx) + Math.abs(n.vy), 0);

      if (totalVelocity > 0.5 && !isPaused) {
        frameRef.current = requestAnimationFrame(simulate);
      }
    };

    if (frameRef.current) {
      cancelAnimationFrame(frameRef.current);
    }

    if (!isPaused) {
      frameRef.current = requestAnimationFrame(simulate);
    }

    return () => {
      if (frameRef.current) {
        cancelAnimationFrame(frameRef.current);
      }
    };
  }, [activeOptions.length, comparisonsMade.length, scores, isPaused]);

  const edges = comparisonsMade.map(({ winner, loser }, idx) => {
    const winnerNode = nodes.find(n => n.id === winner);
    const loserNode = nodes.find(n => n.id === loser);
    if (!winnerNode || !loserNode) return null;
    return { winner, loser, winnerNode, loserNode, index: idx };
  }).filter(Boolean);

  const maxScore = Math.max(...Object.values(scores), 1);
  const totalNodes = activeOptions.length;

  // Node sizing based on rank (higher rank = larger node)
  const getNodeSize = (optionId, rank) => {
    if (inputMode || comparisonsMade.length === 0) {
      return 14; // All same size during input
    }
    const baseSize = compact ? 12 : 14;
    const maxBonus = compact ? 10 : 14;
    // Rank 1 gets full bonus, last rank gets 0
    const rankBonus = totalNodes > 1 ? ((totalNodes - rank) / (totalNodes - 1)) * maxBonus : maxBonus;
    return baseSize + rankBonus;
  };

  const rankedForKey = [...activeOptions].sort((a, b) => (scores[b] || 0) - (scores[a] || 0));

  if (activeOptions.length === 0) {
    return (
      <div className={`flex items-center justify-center ${compact ? 'h-40' : 'h-64'} text-gray-400 text-sm`}>
        No options to display
      </div>
    );
  }

  // Determine if a node is being compared
  const isComparing = (nodeId) => comparingPair && comparingPair.includes(nodeId);

  // SVG height class
  const svgHeightClass = compact ? 'h-40' : (inputMode ? 'h-44' : 'h-64');

  return (
    <div className={`relative ${(compact || showKey) ? 'flex gap-2' : ''}`}>
      <svg
        ref={svgRef}
        viewBox={`0 0 ${width} ${height}`}
        className={`${(compact || showKey) ? 'w-2/3' : 'w-full'} ${svgHeightClass} ${draggable ? 'cursor-grab' : ''}`}
        style={{ touchAction: 'none', ...(draggedNode ? { cursor: 'grabbing' } : {}) }}
      >
        <defs>
          {/* Tapered arrow gradient */}
          <linearGradient id="arrowGradient" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" stopColor="#8b5cf6" />
            <stop offset="100%" stopColor="#ddd6fe" />
          </linearGradient>
          <linearGradient id="arrowGradientHighlight" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" stopColor="#7c3aed" />
            <stop offset="100%" stopColor="#a78bfa" />
          </linearGradient>
          <marker
            id={compact ? "arrowhead-compact" : "arrowhead"}
            markerWidth="8"
            markerHeight="6"
            refX="7"
            refY="3"
            orient="auto"
          >
            <polygon points="0 0, 8 3, 0 6" fill="#a78bfa" />
          </marker>
          <marker
            id="arrowhead-highlight"
            markerWidth="8"
            markerHeight="6"
            refX="7"
            refY="3"
            orient="auto"
          >
            <polygon points="0 0, 8 3, 0 6" fill="#7c3aed" />
          </marker>
          {/* Glow filter for top ranks */}
          <filter id="glow-gold" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
            <feMerge>
              <feMergeNode in="coloredBlur"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>
          <filter id="glow-purple" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
            <feMerge>
              <feMergeNode in="coloredBlur"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>
        </defs>

        {/* Render tapered arrows */}
        {edges.map((edge, i) => {
          const dx = edge.loserNode.x - edge.winnerNode.x;
          const dy = edge.loserNode.y - edge.winnerNode.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          const winnerSize = getNodeSize(edge.winner, edge.winnerNode.rank);
          const loserSize = getNodeSize(edge.loser, edge.loserNode.rank);
          const offsetX1 = (dx / dist) * (winnerSize + 2);
          const offsetY1 = (dy / dist) * (winnerSize + 2);
          const offsetX2 = (dx / dist) * (loserSize + 6);
          const offsetY2 = (dy / dist) * (loserSize + 6);

          const x1 = edge.winnerNode.x + offsetX1;
          const y1 = edge.winnerNode.y + offsetY1;
          const x2 = edge.loserNode.x - offsetX2;
          const y2 = edge.loserNode.y - offsetY2;

          const isSelectedHighlight = selectedNode &&
            (edge.winner === selectedNode || edge.loser === selectedNode);
          const isNew = edge.index === newArrowIndex;

          // Tapered stroke: thick at winner (4px), thin at loser (1px)
          const perpX = -dy / dist;
          const perpY = dx / dist;
          const thickWidth = isSelectedHighlight ? 3.5 : 2;
          const thinWidth = isSelectedHighlight ? 1.5 : 0.5;

          // Create tapered polygon points
          const points = [
            `${x1 + perpX * thickWidth},${y1 + perpY * thickWidth}`,
            `${x1 - perpX * thickWidth},${y1 - perpY * thickWidth}`,
            `${x2 - perpX * thinWidth},${y2 - perpY * thinWidth}`,
            `${x2 + perpX * thinWidth},${y2 + perpY * thinWidth}`,
          ].join(' ');

          const baseOpacity = comparingPair ? 0.3 : 0.6;
          const opacity = selectedNode
            ? (isSelectedHighlight ? 1 : 0.1)
            : (isNew ? 1 : baseOpacity);

          return (
            <g key={i} className={isNew ? 'arrow-new' : ''}>
              <polygon
                points={points}
                fill={isSelectedHighlight ? 'url(#arrowGradientHighlight)' : 'url(#arrowGradient)'}
                opacity={opacity}
              />
              {/* Arrowhead at loser end */}
              <polygon
                points={`${x2},${y2} ${x2 - 6 * dx/dist + 4 * perpX},${y2 - 6 * dy/dist + 4 * perpY} ${x2 - 6 * dx/dist - 4 * perpX},${y2 - 6 * dy/dist - 4 * perpY}`}
                fill={isSelectedHighlight ? '#7c3aed' : '#a78bfa'}
                opacity={opacity}
              />
            </g>
          );
        })}

        {/* Render nodes */}
        {nodes.map((node) => {
          const size = getNodeSize(node.id, node.rank);
          const isDragging = draggedNode === node.id;
          const isBeingCompared = isComparing(node.id);
          const isSelected = selectedNode === node.id;
          const isNewNode = newNodes.current.has(node.id);
          const isTop3 = node.rank <= 3 && comparisonsMade.length > 0;
          const isRevealed = !isResultsView || revealedNodes.has(node.id);

          // Check if this node is connected to selected node
          const isConnectedToSelected = selectedNode && edges.some(e =>
            (e.winner === selectedNode && e.loser === node.id) ||
            (e.loser === selectedNode && e.winner === node.id)
          );

          // Fade non-compared nodes during comparison, or non-selected during selection
          const nodeOpacity = comparingPair && !isBeingCompared ? 0.4 :
                             (selectedNode && !isSelected && !isConnectedToSelected ? 0.3 : 1);

          // Node fill color
          const getFill = () => {
            if (inputMode && comparisonsMade.length === 0) return '#e5e7eb';
            if (node.rank === 1) return '#fbbf24';
            if (node.rank === 2) return '#9ca3af';
            if (node.rank === 3) return '#fb923c';
            return '#e5e7eb';
          };

          // Apply glow filter for top rank or comparing
          const filter = isTop3 && node.rank === 1 ? 'url(#glow-gold)' :
                        (isBeingCompared ? 'url(#glow-purple)' : 'none');

          // Animation class
          let animClass = '';
          if (isNewNode) animClass = 'node-pop';
          else if (isBeingCompared) animClass = 'node-comparing';
          else if (inputMode && comparisonsMade.length === 0) animClass = 'node-float';

          if (!isRevealed && isResultsView) return null;

          return (
            <g
              key={node.id}
              onMouseDown={(e) => handleMouseDown(e, node.id)}
              onTouchStart={(e) => handleMouseDown(e, node.id)}
              onClick={() => onNodeClick && onNodeClick(node.id)}
              className={`${draggable ? 'cursor-grab' : 'cursor-pointer'} ${animClass}`}
              style={{
                ...(isDragging ? { cursor: 'grabbing' } : {}),
                opacity: nodeOpacity,
                transition: 'opacity 0.2s ease',
              }}
              filter={filter}
            >
              {/* Outer glow ring for comparing nodes */}
              {isBeingCompared && (
                <circle
                  cx={node.x}
                  cy={node.y}
                  r={size + 6}
                  fill="none"
                  stroke="#8b5cf6"
                  strokeWidth="2"
                  opacity="0.5"
                />
              )}
              <circle
                cx={node.x}
                cy={node.y}
                r={size}
                fill={getFill()}
                stroke={isDragging || isSelected ? '#7c3aed' : isBeingCompared ? '#8b5cf6' : '#fff'}
                strokeWidth={isDragging || isBeingCompared || isSelected ? 4 : 2}
              />
              <text
                x={node.x}
                y={node.y}
                textAnchor="middle"
                dominantBaseline="middle"
                fontSize={Math.max(8, Math.min(12, size * 0.6))}
                fontWeight="bold"
                fill={node.rank <= 3 && comparisonsMade.length > 0 ? '#1f2937' : '#6b7280'}
                style={{ pointerEvents: 'none' }}
              >
                {comparisonsMade.length > 0 ? node.rank : ''}
              </text>
            </g>
          );
        })}
      </svg>
      
      {(compact || showKey) ? (
        <div className={`w-1/3 flex flex-col text-xs overflow-hidden ${showKey ? 'max-h-64 overflow-y-auto pr-1' : 'justify-center'}`}>
          <div className="space-y-0.5">
            {rankedForKey.map((option, i) => {
              const isSelected = selectedNode === option;
              // Check if connected to selected
              const isConnectedToSelected = selectedNode && edges.some(e =>
                (e.winner === selectedNode && e.loser === option) ||
                (e.loser === selectedNode && e.winner === option)
              );
              const shouldFade = selectedNode && !isSelected && !isConnectedToSelected;

              return (
                <div
                  key={option}
                  className={`flex items-center gap-1.5 py-1 px-1.5 rounded cursor-pointer transition-all duration-150 ${
                    isSelected ? 'bg-violet-100 text-violet-700' :
                    isConnectedToSelected ? 'bg-violet-50 text-violet-600' :
                    'text-gray-600'
                  }`}
                  style={{ opacity: shouldFade ? 0.4 : 1 }}
                  onClick={() => onNodeClick && onNodeClick(option)}
                >
                  <span className={`w-5 h-5 flex-shrink-0 flex items-center justify-center rounded-full text-xs font-bold ${
                    i === 0 ? 'bg-yellow-400 text-yellow-900' :
                    i === 1 ? 'bg-gray-300 text-gray-700' :
                    i === 2 ? 'bg-orange-300 text-orange-900' :
                    'bg-gray-100 text-gray-500'
                  }`}>
                    {i + 1}
                  </span>
                  <span className="truncate text-[11px] leading-tight">{option}</span>
                </div>
              );
            })}
          </div>
          {draggable && !compact && (
            <p className="text-gray-400 text-[10px] mt-2 text-center">Drag nodes to explore</p>
          )}
        </div>
      ) : inputMode ? (
        <div className="text-center mt-2 h-6">
          {activeOptions.length > 0 ? (
            <span className="text-xs text-gray-400">{activeOptions.length} option{activeOptions.length !== 1 ? 's' : ''} ready</span>
          ) : (
            <span className="text-xs text-gray-400">Type options to see them appear</span>
          )}
        </div>
      ) : (
        <div className="text-center mt-2 h-6">
          {selectedNode ? (
            <span className="text-sm text-violet-700 font-medium">{selectedNode}</span>
          ) : (
            <span className="text-xs text-gray-400">Tap a node to highlight connections</span>
          )}
        </div>
      )}
    </div>
  );
}

function MatchupMatrix({ options, comparisonsMade, scores }) {
  const rankedOptions = [...options].sort((a, b) => scores[b] - scores[a]);
  
  const matchups = {};
  comparisonsMade.forEach(({ winner, loser }) => {
    matchups[`${winner}|${loser}`] = 'win';
    matchups[`${loser}|${winner}`] = 'loss';
  });

  const getResult = (row, col) => {
    if (row === col) return 'self';
    return matchups[`${row}|${col}`] || 'none';
  };

  const truncate = (str, len = 8) => 
    str.length > len ? str.slice(0, len) + '…' : str;

  return (
    <div className="overflow-x-auto">
      <table className="w-full text-xs">
        <thead>
          <tr>
            <th className="p-1"></th>
            {rankedOptions.map((opt, i) => (
              <th key={opt} className="p-1 font-medium text-gray-500 truncate max-w-[60px]" title={opt}>
                {i + 1}
              </th>
            ))}
          </tr>
        </thead>
        <tbody>
          {rankedOptions.map((rowOpt) => (
            <tr key={rowOpt}>
              <td className="p-1 font-medium text-gray-700 truncate max-w-[80px]" title={rowOpt}>
                {truncate(rowOpt)}
              </td>
              {rankedOptions.map((colOpt) => {
                const result = getResult(rowOpt, colOpt);
                return (
                  <td 
                    key={colOpt}
                    className={`p-1 w-8 h-8 text-center ${
                      result === 'self' ? 'bg-gray-100' :
                      result === 'win' ? 'bg-green-100 text-green-700' :
                      result === 'loss' ? 'bg-red-100 text-red-700' :
                      'bg-gray-50 text-gray-300'
                    }`}
                  >
                    {result === 'self' ? '—' : result === 'win' ? 'W' : result === 'loss' ? 'L' : '·'}
                  </td>
                );
              })}
            </tr>
          ))}
        </tbody>
      </table>
      <div className="flex justify-center gap-4 mt-3 text-xs text-gray-500">
        <span><span className="inline-block w-3 h-3 bg-green-100 mr-1 rounded"></span>Win</span>
        <span><span className="inline-block w-3 h-3 bg-red-100 mr-1 rounded"></span>Loss</span>
        <span><span className="inline-block w-3 h-3 bg-gray-50 mr-1 rounded border"></span>Not compared</span>
      </div>
    </div>
  );
}

function StrengthChart({ options, scores, selectedNode = null, onNodeClick = null }) {
  const rankedOptions = [...options].sort((a, b) => scores[b] - scores[a]);
  const maxScore = Math.max(...Object.values(scores), 1);

  return (
    <div className="space-y-2">
      {rankedOptions.map((option, index) => {
        const percentage = (scores[option] / maxScore) * 100;
        const isSelected = selectedNode === option;
        return (
          <div
            key={option}
            className={`flex items-center gap-2 cursor-pointer transition-all duration-150 p-1 -m-1 rounded-lg ${
              isSelected ? 'bg-violet-50 scale-[1.02]' : 'hover:bg-gray-50'
            }`}
            onClick={() => onNodeClick && onNodeClick(option)}
          >
            <span className={`w-6 h-6 flex items-center justify-center rounded-full text-xs font-bold transition-all ${
              index === 0 ? 'bg-yellow-400 text-yellow-900' :
              index === 1 ? 'bg-gray-300 text-gray-700' :
              index === 2 ? 'bg-orange-300 text-orange-900' :
              'bg-gray-200 text-gray-600'
            } ${isSelected ? 'ring-2 ring-violet-400 ring-offset-1' : ''}`}>
              {index + 1}
            </span>
            <div className="flex-1">
              <div className="flex justify-between mb-1">
                <span className={`text-sm font-medium truncate transition-colors ${isSelected ? 'text-violet-700' : 'text-gray-700'}`} title={option}>
                  {option}
                </span>
                <span className="text-xs text-gray-500">{scores[option]} wins</span>
              </div>
              <div className="w-full bg-gray-200 rounded-full h-2">
                <div
                  className={`h-2 rounded-full transition-all duration-500 ${
                    index === 0 ? 'bg-yellow-400' :
                    index === 1 ? 'bg-gray-400' :
                    index === 2 ? 'bg-orange-400' :
                    'bg-violet-400'
                  }`}
                  style={{ width: `${Math.max(percentage, 5)}%` }}
                />
              </div>
            </div>
          </div>
        );
      })}
    </div>
  );
}

function ResultsView({ comparisonsMade, scores, options, reset }) {
  const { ShareCardFooter } = window;
  const [activeTab, setActiveTab] = useState('network');
  const [shareStatus, setShareStatus] = useState(null);
  const [showConfetti, setShowConfetti] = useState(true);
  const [selectedNode, setSelectedNode] = useState(null);
  const shareCardRef = useRef(null);

  const rankedOptions = [...options].sort((a, b) => (scores[b] || 0) - (scores[a] || 0));

  // Handle bidirectional sync - toggle selection on/off
  const handleNodeClick = (nodeId) => {
    setSelectedNode(prev => prev === nodeId ? null : nodeId);
  };

  const shareResults = async () => {
    if (!shareCardRef.current) return;
    setShareStatus('generating');

    try {
      const canvas = await html2canvas(shareCardRef.current, {
        backgroundColor: null,
        scale: 2,
        logging: false,
      });

      const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
      const file = new File([blob], 'ranking-result.png', { type: 'image/png' });

      if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
        await navigator.share({
          files: [file],
          title: 'My Ranking Results',
          text: `My top choice: ${rankedOptions[0]}`,
        });
        setShareStatus('shared');
      } else {
        // Download image when file sharing not supported
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'ranking-result.png';
        a.click();
        URL.revokeObjectURL(url);
        setShareStatus('downloaded');
      }
    } catch (err) {
      if (err.name !== 'AbortError') {
        const text = `My ranking: ${rankedOptions.slice(0, 3).join(', ')}...\nMade with Marco's Decision Tools`;
        await navigator.clipboard.writeText(text);
        setShareStatus('copied');
      } else {
        setShareStatus(null);
        return;
      }
    }
    setTimeout(() => setShareStatus(null), 2500);
  };

  const getShareButtonText = () => {
    switch (shareStatus) {
      case 'generating': return '...';
      case 'shared': return 'Shared';
      case 'downloaded': return 'Saved';
      case 'copied': return 'Copied';
      default: return 'Share';
    }
  };
  
  const tabs = [
    { id: 'network', label: 'Network' },
    { id: 'ranking', label: 'Ranking' },
    { id: 'matrix', label: 'Matchups' },
  ];

  return (
    <div className="bg-white rounded-2xl shadow-xl p-8">
      <Confetti show={showConfetti} />
      {/* Hidden share card - Instagram optimized 540x540 */}
      <div style={{ position: 'absolute', left: '-9999px', top: 0 }}>
        <div
          ref={shareCardRef}
          style={{
            width: 540,
            height: 540,
            padding: 32,
            background: 'linear-gradient(135deg, #1e293b 0%, #4c1d95 50%, #1e293b 100%)',
            fontFamily: 'Arial, Helvetica, sans-serif',
            boxSizing: 'border-box',
            display: 'flex',
            flexDirection: 'column',
          }}
        >
          <div style={{ textAlign: 'center', marginBottom: 20 }}>
            <div style={{ fontSize: 16, color: '#a78bfa', marginBottom: 6, letterSpacing: 1, textTransform: 'uppercase' }}>{'My Ranking Results'}</div>
            <div style={{ fontSize: 13, color: '#94a3b8', letterSpacing: 0 }}>{comparisonsMade.length} {'comparisons made'}</div>
          </div>

          {/* Winner highlight */}
          <div style={{
            background: 'linear-gradient(135deg, #8b5cf6 0%, #a855f7 100%)',
            borderRadius: 16,
            padding: 20,
            textAlign: 'center',
            marginBottom: 16,
            boxShadow: '0 4px 20px rgba(139, 92, 246, 0.3)',
          }}>
            <div style={{ fontSize: 12, color: 'rgba(255,255,255,0.8)', marginBottom: 8, letterSpacing: 0 }}>{'#1 Choice'}</div>
            <div style={{ fontSize: 28, fontWeight: 'bold', color: 'white', letterSpacing: 0 }}>{rankedOptions[0]}</div>
          </div>

          {/* Full ranking */}
          <div style={{ background: 'rgba(255,255,255,0.08)', borderRadius: 12, padding: 16, flex: 1 }}>
            {rankedOptions.slice(0, 6).map((option, idx) => (
              <div key={idx} style={{
                display: 'flex',
                alignItems: 'center',
                gap: 12,
                padding: '8px 0',
                borderBottom: idx < Math.min(rankedOptions.length, 6) - 1 ? '1px solid rgba(255,255,255,0.1)' : 'none',
              }}>
                <div style={{
                  width: 28,
                  height: 28,
                  borderRadius: '50%',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  fontSize: 12,
                  fontWeight: 'bold',
                  background: idx === 0 ? '#fbbf24' : idx === 1 ? '#94a3b8' : idx === 2 ? '#f97316' : 'rgba(255,255,255,0.15)',
                  color: idx === 0 ? '#78350f' : idx === 1 ? '#1e293b' : idx === 2 ? '#7c2d12' : '#e2e8f0',
                }}>{idx + 1}</div>
                <span style={{ fontSize: 15, color: idx === 0 ? '#fbbf24' : '#e2e8f0', letterSpacing: 0, fontWeight: idx === 0 ? 'bold' : 'normal' }}>{option}</span>
              </div>
            ))}
            {rankedOptions.length > 6 && (
              <div style={{ fontSize: 12, color: '#94a3b8', textAlign: 'center', marginTop: 8 }}>
                +{rankedOptions.length - 6} more
              </div>
            )}
          </div>

          <ShareCardFooter style={{ marginTop: 16 }} />
        </div>
      </div>

      <div className="flex items-center justify-between mb-2">
        <h2 className="text-2xl font-bold text-gray-800">Your Rankings</h2>
        <button
          onClick={shareResults}
          disabled={shareStatus === 'generating'}
          className={`text-sm px-3 py-1 rounded-lg transition-colors flex items-center gap-1 ${
            shareStatus && shareStatus !== 'generating'
              ? 'bg-green-100 text-green-700'
              : 'bg-gray-100 hover:bg-gray-200 text-gray-600'
          }`}
        >
          {!shareStatus && (
            <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z" />
            </svg>
          )}
          {getShareButtonText()}
        </button>
      </div>
      <p className="text-gray-500 mb-4">
        Based on {comparisonsMade.length} comparisons
      </p>

      <div className="flex gap-1 mb-6 bg-gray-100 p-1 rounded-lg">
        {tabs.map(tab => (
          <button
            key={tab.id}
            onClick={() => setActiveTab(tab.id)}
            className={`flex-1 py-2 px-3 text-sm font-medium rounded-md transition-all ${
              activeTab === tab.id 
                ? 'bg-white text-violet-700 shadow-sm' 
                : 'text-gray-600 hover:text-gray-800'
            }`}
          >
            {tab.label}
          </button>
        ))}
      </div>

      <div className="min-h-[280px]">
        {activeTab === 'ranking' && (
          <StrengthChart
            options={options}
            scores={scores}
            selectedNode={selectedNode}
            onNodeClick={handleNodeClick}
          />
        )}
        
        {activeTab === 'network' && (
          <NetworkGraph
            options={options}
            comparisonsMade={comparisonsMade}
            scores={scores}
            showKey={true}
            draggable={true}
            isResultsView={true}
            selectedNode={selectedNode}
            onNodeClick={handleNodeClick}
          />
        )}
        
        {activeTab === 'matrix' && (
          <MatchupMatrix 
            options={options}
            comparisonsMade={comparisonsMade}
            scores={scores}
          />
        )}
      </div>

      <button
        onClick={reset}
        className="w-full mt-6 py-3 bg-violet-600 hover:bg-violet-700 text-white font-semibold rounded-xl transition-colors"
      >
        Start Over
      </button>
    </div>
  );
}

// localStorage helpers
const STORAGE_KEY = 'choice-ranker-history';

function loadHistory() {
  try {
    const data = localStorage.getItem(STORAGE_KEY);
    return data ? JSON.parse(data) : [];
  } catch { return []; }
}

function saveToHistory(items) {
  const history = loadHistory();
  const entry = {
    id: Date.now(),
    items,
    date: new Date().toLocaleDateString(),
    preview: items.slice(0, 3).join(', ') + (items.length > 3 ? '...' : '')
  };
  // Keep max 10 entries, avoid duplicates
  const isDuplicate = history.some(h => JSON.stringify(h.items) === JSON.stringify(items));
  if (!isDuplicate) {
    history.unshift(entry);
    if (history.length > 10) history.pop();
    localStorage.setItem(STORAGE_KEY, JSON.stringify(history));
  }
}

function deleteFromHistory(id) {
  const history = loadHistory().filter(h => h.id !== id);
  localStorage.setItem(STORAGE_KEY, JSON.stringify(history));
}

function App() {
  const { ShareCardFooter } = window;
  const [stage, setStage] = useState('input');
  const [optionInputs, setOptionInputs] = useState(['', '', '']);
  const [history, setHistory] = useState([]);
  const [showHistory, setShowHistory] = useState(false);

  useEffect(() => {
    setHistory(loadHistory());
  }, []);
  const [options, setOptions] = useState([]);
  const [scores, setScores] = useState({});
  const [comparisons, setComparisons] = useState([]);
  const [comparisonsMade, setComparisonsMade] = useState([]);
  const [totalEstimate, setTotalEstimate] = useState(0);
  
  const smartState = useRef(null);
  const [smartExplanation, setSmartExplanation] = useState('');
  const [smartEstimatedLeft, setSmartEstimatedLeft] = useState(0);

  const initSmart = (items) => {
    smartState.current = { items: [...items], wins: {}, compared: new Set() };
    items.forEach(item => { smartState.current.wins[item] = {}; });
    setSmartEstimatedLeft(Math.ceil(items.length * Math.log2(items.length)));
    return getNextSmartPair();
  };

  const getWinProbability = (a, b, wins, items) => {
    if (wins[a]?.[b]) return 1;
    if (wins[b]?.[a]) return 0;
    
    let aAdvantage = 0;
    items.forEach(other => {
      if (other === a || other === b) return;
      if (wins[a]?.[other] && wins[other]?.[b]) aAdvantage += 0.5;
      if (wins[b]?.[other] && wins[other]?.[a]) aAdvantage -= 0.5;
      if (wins[a]?.[other]) aAdvantage += 0.1;
      if (wins[b]?.[other]) aAdvantage -= 0.1;
    });
    
    return 0.5 + Math.max(-0.4, Math.min(0.4, aAdvantage * 0.2));
  };

  const getComparisonValue = (a, b, wins, items) => {
    const p = getWinProbability(a, b, wins, items);
    if (p <= 0 || p >= 1) return 0;
    return -p * Math.log2(p) - (1 - p) * Math.log2(1 - p);
  };

  const getQuestionExplanation = (a, b, wins, items) => {
    const p = getWinProbability(a, b, wins, items);
    const aWins = Object.keys(wins[a] || {}).length;
    const bWins = Object.keys(wins[b] || {}).length;
    const aTransitive = items.filter(x => wins[a]?.[x] && wins[x]?.[b]);
    const bTransitive = items.filter(x => wins[b]?.[x] && wins[x]?.[a]);
    
    if (aWins === 0 && bWins === 0) return "First time seeing both — need direct comparison";
    if (aWins === 0) return `Introducing "${a}" against established option`;
    if (bWins === 0) return `Introducing "${b}" against established option`;
    if (Math.abs(p - 0.5) < 0.1) return "These are very close — this will help break the tie";
    if (aTransitive.length > 0 || bTransitive.length > 0) return "Verifying transitive assumption";
    if (Math.abs(aWins - bWins) <= 1) return "Similar win counts — determining relative ranking";
    return "Filling in comparison data for confidence";
  };

  const estimateRemainingQuestions = (wins, items, compared) => {
    let uncertainPairs = 0;
    for (let i = 0; i < items.length; i++) {
      for (let j = i + 1; j < items.length; j++) {
        const key = [items[i], items[j]].sort().join('|');
        if (compared.has(key)) continue;
        const p = getWinProbability(items[i], items[j], wins, items);
        if (Math.abs(p - 0.5) < 0.35) uncertainPairs++;
      }
    }
    return Math.min(uncertainPairs, Math.ceil(items.length * 0.8));
  };

  const isRankingConfident = (wins, items) => {
    const ranked = [...items].sort((a, b) => 
      Object.keys(wins[b] || {}).length - Object.keys(wins[a] || {}).length
    );
    
    for (let i = 0; i < ranked.length - 1; i++) {
      if (!wins[ranked[i]]?.[ranked[i + 1]]) {
        if (getWinProbability(ranked[i], ranked[i + 1], wins, items) < 0.7) return false;
      }
    }
    return true;
  };

  const getNextSmartPair = () => {
    const state = smartState.current;
    if (!state) return null;
    
    const { items, wins, compared } = state;
    
    if (compared.size >= items.length && isRankingConfident(wins, items)) {
      setSmartExplanation('');
      setSmartEstimatedLeft(0);
      return null;
    }
    
    let bestPair = null;
    let bestValue = -1;
    
    for (let i = 0; i < items.length; i++) {
      for (let j = i + 1; j < items.length; j++) {
        const key = [items[i], items[j]].sort().join('|');
        if (compared.has(key)) continue;
        const value = getComparisonValue(items[i], items[j], wins, items);
        if (value > bestValue) {
          bestValue = value;
          bestPair = [items[i], items[j]];
        }
      }
    }
    
    if (!bestPair || bestValue < 0.1) {
      setSmartExplanation('');
      setSmartEstimatedLeft(0);
      return null;
    }
    
    setSmartExplanation(getQuestionExplanation(bestPair[0], bestPair[1], wins, items));
    setSmartEstimatedLeft(estimateRemainingQuestions(wins, items, compared));
    
    return Math.random() > 0.5 ? bestPair : [bestPair[1], bestPair[0]];
  };

  const handleSmartChoice = (winner, loser) => {
    const state = smartState.current;
    state.wins[winner][loser] = true;
    state.compared.add([winner, loser].sort().join('|'));
    return getNextSmartPair();
  };

  const getSmartRanking = () => {
    const state = smartState.current;
    if (!state) return [];
    const { items, wins } = state;
    
    return [...items].sort((a, b) => {
      const aWins = Object.keys(wins[a] || {}).length;
      const bWins = Object.keys(wins[b] || {}).length;
      if (bWins !== aWins) return bWins - aWins;
      
      const aStrength = Object.keys(wins[a] || {}).reduce((sum, d) => 
        sum + Object.keys(wins[d] || {}).length, 0);
      const bStrength = Object.keys(wins[b] || {}).reduce((sum, d) => 
        sum + Object.keys(wins[d] || {}).length, 0);
      return bStrength - aStrength;
    });
  };

  const estimateComparisons = (n, selectedMode) => {
    if (selectedMode === 'complete') return (n * (n - 1)) / 2;
    if (selectedMode === 'balanced') {
      const complete = (n * (n - 1)) / 2;
      return Math.min(Math.max(Math.floor(n * 1.5), Math.floor(complete * 0.6)), complete - 1);
    }
    if (selectedMode === 'smart') return Math.ceil(n * Math.log2(n) * 1.2) + '?';
    if (selectedMode === 'quick') return Math.ceil(n * Math.log2(n));
    return n - 1;
  };

  const loadFromHistory = (entry) => {
    // Ensure at least 3 fields
    const items = entry.items.length >= 3 ? entry.items : [...entry.items, ...Array(3 - entry.items.length).fill('')];
    setOptionInputs(items);
    setShowHistory(false);
  };

  const handleDeleteHistory = (id, e) => {
    e.stopPropagation();
    deleteFromHistory(id);
    setHistory(loadHistory());
  };

  const startComparing = () => {
    const items = optionInputs.map(s => s.trim()).filter(s => s.length > 0);

    if (items.length < 3) {
      alert('Please enter at least 3 options');
      return;
    }

    // Save to history
    saveToHistory(items);
    setHistory(loadHistory());

    const initialScores = {};
    items.forEach(item => { initialScores[item] = 0; });

    setOptions(items);
    setScores(initialScores);
    setComparisonsMade([]);
    setTotalEstimate(estimateComparisons(items.length, 'smart'));

    const firstPair = initSmart(items);
    if (firstPair) { setComparisons([firstPair]); setStage('comparing'); }
  };

  const handleChoice = (winner, loser) => {
    const newScores = { ...scores };
    newScores[winner] = (newScores[winner] || 0) + 1;
    setScores(newScores);

    setComparisonsMade(prev => [...prev, { winner, loser }]);

    const nextPair = handleSmartChoice(winner, loser);
    if (nextPair) setComparisons([nextPair]);
    else { setOptions(getSmartRanking()); setStage('result'); }
  };

  const reset = () => {
    setStage('input');
    setOptionInputs(['', '', '']);
    setOptions([]);
    setScores({});
    setComparisons([]);
    setComparisonsMade([]);
    smartState.current = null;
  };

  const progress = totalEstimate > 0 && typeof totalEstimate === 'number'
    ? Math.min(Math.round((comparisonsMade.length / totalEstimate) * 100), 99) : 0;

  const currentPair = comparisons[0];

  const getButtonOrder = (pair) => {
    if (!pair) return pair;
    const hash = pair[0].length + pair[1].length + pair[0].charCodeAt(0);
    return hash % 2 === 0 ? pair : [pair[1], pair[0]];
  };

  const itemCount = optionInputs.filter(s => s.trim().length > 0).length;

  return (
    <div className="h-full bg-gradient-to-br from-violet-50 to-indigo-100 p-4 flex items-center justify-center overflow-auto">
      <a href="/my-tools/" className="absolute top-4 left-4 p-2 bg-white/80 hover:bg-white rounded-full shadow-sm transition-colors">
          <svg className="w-5 h-5 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
          </svg>
        </a>
        <div className="w-full max-w-xl my-auto">
        
        {stage === 'input' && (
          <div className="bg-white rounded-2xl shadow-xl p-6">
            <h1 className="text-2xl font-bold text-gray-800 mb-2">Choice Ranker</h1>
            <p className="text-gray-500 mb-4 text-sm">Enter your options to compare and rank.</p>

            {/* Graph + Input side by side on larger screens, stacked on mobile */}
            <div className="flex flex-col md:flex-row gap-4">
              <div className="flex-1 space-y-2">
                {optionInputs.map((value, idx) => (
                  <div key={idx} className="flex items-center gap-2">
                    <input
                      type="text"
                      value={value}
                      onChange={(e) => {
                        const newInputs = [...optionInputs];
                        newInputs[idx] = e.target.value;
                        setOptionInputs(newInputs);
                      }}
                      placeholder={`Option ${idx + 1}`}
                      className="flex-1 p-3 border border-gray-200 rounded-xl text-gray-700 placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-violet-400"
                    />
                    {optionInputs.length > 3 && (
                      <button
                        onClick={() => setOptionInputs(optionInputs.filter((_, i) => i !== idx))}
                        className="w-10 h-10 flex items-center justify-center text-gray-400 hover:text-red-500 hover:bg-red-50 rounded-lg transition-colors"
                      >
                        <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                          <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                      </button>
                    )}
                  </div>
                ))}
                <button
                  onClick={() => setOptionInputs([...optionInputs, ''])}
                  className="w-full py-2 text-sm text-violet-600 hover:text-violet-700 hover:bg-violet-50 rounded-lg transition-colors flex items-center justify-center gap-1"
                >
                  <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                    <path strokeLinecap="round" strokeLinejoin="round" d="M12 4v16m8-8H4" />
                  </svg>
                  Add option
                </button>

                {history.length > 0 && (
                  <div className="mt-2 pt-2 border-t border-gray-100">
                    <button
                      onClick={() => setShowHistory(!showHistory)}
                      className="text-sm text-gray-500 hover:text-violet-600 flex items-center gap-1"
                    >
                      {showHistory ? 'Hide' : 'Load'} previous ({history.length})
                      <svg className={`w-4 h-4 transition-transform ${showHistory ? 'rotate-180' : ''}`} fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                      </svg>
                    </button>
                    {showHistory && (
                      <div className="mt-2 space-y-2 max-h-40 overflow-y-auto">
                        {history.map(entry => (
                          <div
                            key={entry.id}
                            onClick={() => loadFromHistory(entry)}
                            className="flex items-center justify-between p-2 bg-gray-50 hover:bg-violet-50 rounded-lg cursor-pointer group"
                          >
                            <div className="flex-1 min-w-0">
                              <p className="text-sm text-gray-700 truncate">{entry.preview}</p>
                              <p className="text-xs text-gray-400">{entry.items.length} items · {entry.date}</p>
                            </div>
                            <button
                              onClick={(e) => handleDeleteHistory(entry.id, e)}
                              className="ml-2 p-2 min-w-[44px] min-h-[44px] flex items-center justify-center text-gray-400 hover:text-red-500 hover:bg-red-50 rounded-lg transition-colors"
                            >
                              <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2.5}>
                                <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
                              </svg>
                            </button>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                )}
              </div>

              {/* Live graph preview - shows nodes for all input fields */}
              <div className="flex-1 bg-gradient-to-br from-violet-50 to-indigo-50 rounded-xl p-2 border border-violet-100">
                <NetworkGraph
                  options={optionInputs.map((s, idx) => s.trim() || `Option ${idx + 1}`)}
                  comparisonsMade={[]}
                  scores={{}}
                  inputMode={true}
                  draggable={false}
                />
              </div>
            </div>

            <button
              onClick={startComparing}
              className="w-full mt-4 py-3 bg-violet-600 hover:bg-violet-700 text-white font-semibold rounded-xl"
            >
              Start Comparing
            </button>
          </div>
        )}

        {stage === 'comparing' && currentPair && (
          <div className="bg-white rounded-2xl shadow-xl p-6">
            <div className="text-center mb-3">
              <p className="text-sm text-gray-500 mb-2">
                Question {comparisonsMade.length + 1}
                {smartEstimatedLeft > 0 && (
                  <span className="text-violet-600 ml-2">~{smartEstimatedLeft} left</span>
                )}
              </p>
              <div className="w-full bg-gray-200 rounded-full h-2">
                <div
                  className="bg-violet-600 h-2 rounded-full transition-all"
                  style={{ width: `${Math.min(progress, 95)}%` }}
                />
              </div>
            </div>

            <div className="mb-3 -mx-2">
              <NetworkGraph
                options={options}
                comparisonsMade={comparisonsMade}
                scores={scores}
                compact={true}
                draggable={true}
                comparingPair={currentPair}
              />
            </div>

            <h2 className="text-lg font-semibold text-gray-800 text-center mb-1">
              Which do you prefer?
            </h2>

            {smartExplanation && (
              <p className="text-xs text-gray-400 text-center mb-3 italic">{smartExplanation}</p>
            )}

            <div className="space-y-2">
              {getButtonOrder(currentPair).map((option, idx) => (
                <button
                  key={option + idx}
                  onClick={() => handleChoice(option, currentPair.find(o => o !== option))}
                  className="w-full p-4 text-lg font-medium text-gray-700 bg-gray-50 hover:bg-violet-100 hover:text-violet-700 border-2 border-gray-200 hover:border-violet-400 rounded-xl transition-all active:scale-[0.98]"
                >
                  {option}
                </button>
              ))}
            </div>
          </div>
        )}

        {stage === 'result' && (
          <ResultsView
            comparisonsMade={comparisonsMade}
            scores={scores}
            options={options}
            reset={reset}
          />
        )}
      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
