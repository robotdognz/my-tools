<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Decision Battle</title>
  <meta name="theme-color" content="#dc2626">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
  <script src="../shared/share-card.js"></script>
  <style>
    * { -webkit-tap-highlight-color: transparent; }
    html, body, #root { height: 100%; margin: 0; overflow: hidden; }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px) rotate(-1deg); }
      75% { transform: translateX(5px) rotate(1deg); }
    }

    @keyframes hit-left {
      0% { transform: scale(1); }
      50% { transform: scale(0.9); filter: brightness(2); }
      100% { transform: scale(1); }
    }

    @keyframes hit-right {
      0% { transform: scaleX(-1) scale(1); }
      50% { transform: scaleX(-1) scale(0.9); filter: brightness(2); }
      100% { transform: scaleX(-1) scale(1); }
    }

    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 0 20px currentColor; }
      50% { box-shadow: 0 0 40px currentColor, 0 0 60px currentColor; }
    }

    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-8px); }
    }

    @keyframes float-flipped {
      0%, 100% { transform: scaleX(-1) translateY(0); }
      50% { transform: scaleX(-1) translateY(-8px); }
    }

    @keyframes attack-right {
      0% { transform: scaleX(-1) translateX(0); }
      30% { transform: scaleX(-1) translateX(20px); }
      50% { transform: scaleX(-1) translateX(35px) scale(1.1); }
      100% { transform: scaleX(-1) translateX(0); }
    }

    @keyframes attack-left {
      0% { transform: translateX(0); }
      30% { transform: translateX(-20px); }
      50% { transform: translateX(-35px) scale(1.1); }
      100% { transform: translateX(0); }
    }

    @keyframes boost-pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }

    @keyframes powerup-float {
      0% { opacity: 1; transform: translateY(0); }
      100% { opacity: 0; transform: translateY(-30px); }
    }

    @keyframes item-spawn {
      0% { transform: scale(0) rotate(-180deg); opacity: 0; }
      100% { transform: scale(1) rotate(0deg); opacity: 1; }
    }

    @keyframes item-wobble {
      0%, 100% { transform: rotate(-3deg); }
      50% { transform: rotate(3deg); }
    }

    @keyframes drop-zone-pulse {
      0%, 100% { transform: scale(1); opacity: 0.5; }
      50% { transform: scale(1.1); opacity: 0.8; }
    }

    @keyframes crit-hit-left {
      0% { transform: scale(1); }
      25% { transform: scale(0.7) rotate(-10deg); filter: brightness(3) saturate(2); }
      50% { transform: scale(1.1) rotate(5deg); filter: brightness(2); }
      100% { transform: scale(1); }
    }

    @keyframes crit-hit-right {
      0% { transform: scaleX(-1) scale(1); }
      25% { transform: scaleX(-1) scale(0.7) rotate(10deg); filter: brightness(3) saturate(2); }
      50% { transform: scaleX(-1) scale(1.1) rotate(-5deg); filter: brightness(2); }
      100% { transform: scaleX(-1) scale(1); }
    }

    @keyframes screen-shake {
      0%, 100% { transform: translateX(0); }
      10% { transform: translateX(-8px) translateY(4px); }
      20% { transform: translateX(8px) translateY(-4px); }
      30% { transform: translateX(-6px) translateY(2px); }
      40% { transform: translateX(6px) translateY(-2px); }
      50% { transform: translateX(-4px); }
      60% { transform: translateX(4px); }
      70% { transform: translateX(-2px); }
      80% { transform: translateX(2px); }
    }

    @keyframes crit-text {
      0% { opacity: 0; transform: translateY(0) scale(0.5); }
      20% { opacity: 1; transform: translateY(-10px) scale(1.5); }
      40% { transform: translateY(-20px) scale(1.2); }
      100% { opacity: 0; transform: translateY(-40px) scale(1); }
    }

    @keyframes crit-flash {
      0% { opacity: 0; }
      10% { opacity: 0.6; }
      100% { opacity: 0; }
    }

    @keyframes damage-float {
      0% { opacity: 1; transform: translateY(0) scale(1); }
      20% { transform: translateY(-10px) scale(1.2); }
      100% { opacity: 0; transform: translateY(-50px) scale(0.8); }
    }

    @keyframes crit-attacker-glow {
      0% { filter: drop-shadow(0 0 8px currentColor); }
      30% { filter: drop-shadow(0 0 25px #fbbf24) drop-shadow(0 0 40px #f59e0b) brightness(1.3); }
      100% { filter: drop-shadow(0 0 8px currentColor); }
    }

    .shake { animation: shake 0.3s ease-in-out; }
    .hit-left { animation: hit-left 0.3s ease-in-out; }
    .hit-right { animation: hit-right 0.3s ease-in-out; }
    .crit-hit-left { animation: crit-hit-left 0.5s ease-in-out; }
    .crit-hit-right { animation: crit-hit-right 0.5s ease-in-out; }
    .screen-shake { animation: screen-shake 0.4s ease-in-out; }
    .crit-text { animation: crit-text 0.8s ease-out forwards; }
    .crit-flash { animation: crit-flash 0.3s ease-out; }
    .damage-float { animation: damage-float 1s ease-out forwards; }
    .crit-attacker-glow { animation: crit-attacker-glow 0.6s ease-out; }
    .float { animation: float 2s ease-in-out infinite; }
    .float-flipped { animation: float-flipped 2s ease-in-out infinite; }
    .attack-right { animation: attack-right 0.4s ease-out; }
    .attack-left { animation: attack-left 0.4s ease-out; }
    .pulse-glow { animation: pulse-glow 2s ease-in-out infinite; }
    .boost-pulse { animation: boost-pulse 0.3s ease-out; }
    .powerup-float { animation: powerup-float 0.8s ease-out forwards; }
    .item-spawn { animation: item-spawn 0.4s ease-out; }
    .item-wobble { animation: item-wobble 1s ease-in-out infinite; }
    .drop-zone-pulse { animation: drop-zone-pulse 1s ease-in-out infinite; }

    .health-bar {
      transition: width 0.3s ease-out;
    }

    .monster-glow {
      filter: drop-shadow(0 0 8px currentColor);
    }

    .draggable-item {
      cursor: grab;
      touch-action: none;
      user-select: none;
    }

    .draggable-item:active {
      cursor: grabbing;
    }

    .dragging {
      opacity: 0.8;
      z-index: 1000;
    }

    @keyframes confetti-fall {
      0% { transform: translateY(-100%) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }
    .confetti {
      position: fixed;
      width: 10px;
      height: 10px;
      top: -10px;
      animation: confetti-fall 3s ease-out forwards;
      z-index: 1000;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

// Confetti component
function Confetti({ show }) {
  const [pieces, setPieces] = useState([]);

  useEffect(() => {
    if (show) {
      const colors = ['#ef4444', '#f59e0b', '#fbbf24', '#22c55e', '#8b5cf6', '#ec4899'];
      const newPieces = Array.from({ length: 50 }, (_, i) => ({
        id: i,
        left: Math.random() * 100,
        delay: Math.random() * 0.5,
        color: colors[Math.floor(Math.random() * colors.length)],
        size: 6 + Math.random() * 8,
      }));
      setPieces(newPieces);
      const timer = setTimeout(() => setPieces([]), 3500);
      return () => clearTimeout(timer);
    }
  }, [show]);

  if (!show || pieces.length === 0) return null;

  return (
    <>
      {pieces.map(piece => (
        <div
          key={piece.id}
          className="confetti"
          style={{
            left: `${piece.left}%`,
            backgroundColor: piece.color,
            width: piece.size,
            height: piece.size,
            animationDelay: `${piece.delay}s`,
            borderRadius: Math.random() > 0.5 ? '50%' : '0',
          }}
        />
      ))}
    </>
  );
}

// Item types for the battle
const ITEM_TYPES = [
  { type: 'health', emoji: 'üß™', name: 'Health Potion', color: 'from-green-500 to-emerald-600', effect: 'heal', minValue: 8, maxValue: 20, label: 'Heal' },
  { type: 'power', emoji: '‚ö°', name: 'Power Boost', color: 'from-yellow-500 to-orange-600', effect: 'attack', minValue: 2, maxValue: 5, label: '+ATK' },
  { type: 'shield', emoji: 'üõ°Ô∏è', name: 'Shield', color: 'from-slate-400 to-slate-600', effect: 'defense', minValue: 2, maxValue: 5, label: '+DEF' },
  { type: 'poison', emoji: '‚ò†Ô∏è', name: 'Poison', color: 'from-purple-500 to-pink-600', effect: 'damage', minValue: 10, maxValue: 25, label: 'Damage' },
  { type: 'sleep', emoji: 'üí§', name: 'Sleep Spell', color: 'from-blue-500 to-indigo-600', effect: 'sleep', minValue: 1, maxValue: 2, label: 'Sleep' },
];

const MAX_SHELF_ITEMS = 5;

let itemIdCounter = 0;
function generateItem() {
  const type = ITEM_TYPES[Math.floor(Math.random() * ITEM_TYPES.length)];
  const value = Math.floor(Math.random() * (type.maxValue - type.minValue + 1)) + type.minValue;
  itemIdCounter++;
  return {
    ...type,
    id: `item-${Date.now()}-${itemIdCounter}`,
    value,
    isNew: true,
  };
}

// localStorage helpers
const STORAGE_KEY = 'decision-battle-history';

function loadHistory() {
  try {
    const data = localStorage.getItem(STORAGE_KEY);
    return data ? JSON.parse(data) : [];
  } catch { return []; }
}

function saveToHistory(choices) {
  const history = loadHistory();
  const entry = {
    id: Date.now(),
    choices,
    date: new Date().toLocaleDateString(),
    preview: `${choices[0]} vs ${choices[1]}`
  };
  const isDuplicate = history.some(h =>
    h.choices[0] === choices[0] && h.choices[1] === choices[1]
  );
  if (!isDuplicate) {
    history.unshift(entry);
    if (history.length > 10) history.pop();
    localStorage.setItem(STORAGE_KEY, JSON.stringify(history));
  }
}

function deleteFromHistory(id) {
  const history = loadHistory().filter(h => h.id !== id);
  localStorage.setItem(STORAGE_KEY, JSON.stringify(history));
}

// Monster types with different vibes
const MONSTER_TYPES = [
  { emoji: 'üêâ', name: 'Dragon' },
  { emoji: 'üëπ', name: 'Oni' },
  { emoji: 'ü¶Å', name: 'Lion' },
  { emoji: 'üê∫', name: 'Wolf' },
  { emoji: 'ü¶Ö', name: 'Eagle' },
  { emoji: 'üêª', name: 'Bear' },
  { emoji: 'ü¶à', name: 'Shark' },
  { emoji: 'ü¶Ç', name: 'Scorpion' },
  { emoji: 'üêç', name: 'Serpent' },
  { emoji: 'ü¶á', name: 'Bat' },
  { emoji: 'üêó', name: 'Boar' },
  { emoji: 'ü¶é', name: 'Lizard' },
];

const COLORS = [
  { bg: 'bg-gradient-to-br from-red-500 to-orange-600', glow: 'text-red-500', ring: 'ring-red-500', name: 'Crimson' },
  { bg: 'bg-gradient-to-br from-blue-500 to-cyan-600', glow: 'text-blue-500', ring: 'ring-blue-500', name: 'Azure' },
  { bg: 'bg-gradient-to-br from-green-500 to-emerald-600', glow: 'text-green-500', ring: 'ring-green-500', name: 'Verdant' },
  { bg: 'bg-gradient-to-br from-purple-500 to-pink-600', glow: 'text-purple-500', ring: 'ring-purple-500', name: 'Mystic' },
  { bg: 'bg-gradient-to-br from-amber-500 to-yellow-600', glow: 'text-amber-500', ring: 'ring-amber-500', name: 'Golden' },
  { bg: 'bg-gradient-to-br from-slate-500 to-zinc-600', glow: 'text-slate-400', ring: 'ring-slate-500', name: 'Shadow' },
  { bg: 'bg-gradient-to-br from-rose-500 to-red-600', glow: 'text-rose-500', ring: 'ring-rose-500', name: 'Scarlet' },
  { bg: 'bg-gradient-to-br from-teal-500 to-cyan-600', glow: 'text-teal-500', ring: 'ring-teal-500', name: 'Tidal' },
];

// Simple hash function for consistent generation
function hashString(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  return Math.abs(hash);
}

function generateMonster(choice, index) {
  const hash = hashString(choice + index);
  const monsterType = MONSTER_TYPES[hash % MONSTER_TYPES.length];
  // Ensure different colors for each monster
  const colorIndex = index === 0 ? (hash >> 4) % COLORS.length : ((hash >> 4) + 4) % COLORS.length;
  const color = COLORS[colorIndex];

  return {
    choice,
    emoji: monsterType.emoji,
    typeName: monsterType.name,
    color,
    fullName: `${color.name} ${monsterType.name}`,
    maxHp: 100,
    hp: 100,
    attack: 8,
    defense: 3,
    sleepTurns: 0,
  };
}

function Monster({ monster, isLeft, isAttacking, isHit, isCriticalHit, isCritAttacker, isWinner, boostEffect, isDropTarget, effectText, activeEffects, damageText }) {
  return (
    <div className="flex flex-col items-center relative">
      {/* Damage text floating up */}
      {damageText && (
        <div className="absolute -top-4 left-1/2 -translate-x-1/2 pointer-events-none z-30">
          {damageText.isMiss ? (
            <span
              className="text-xl font-black damage-float text-cyan-400 drop-shadow-lg"
              style={{ textShadow: '0 0 10px #22d3ee, 0 0 20px #0891b2' }}
            >
              MISS!
            </span>
          ) : (
            <span
              className={`text-2xl font-black damage-float drop-shadow-lg ${damageText.isCrit ? 'text-yellow-300' : 'text-red-400'}`}
              style={damageText.isCrit ? { textShadow: '0 0 10px #fbbf24, 0 0 20px #f59e0b, 0 0 30px #dc2626' } : { textShadow: '0 0 8px #dc2626' }}
            >
              {damageText.isCrit && 'üí• '}-{damageText.amount}
            </span>
          )}
        </div>
      )}

      {/* Crit attacker indicator */}
      {isCritAttacker && (
        <div className="absolute -top-4 left-1/2 -translate-x-1/2 pointer-events-none z-30">
          <span className="text-xl font-black text-yellow-300 crit-text drop-shadow-lg" style={{ textShadow: '0 0 10px #fbbf24, 0 0 20px #f59e0b' }}>
            CRIT!
          </span>
        </div>
      )}

      {/* Effect text floating up */}
      {effectText && (
        <div className="absolute -top-2 left-1/2 -translate-x-1/2 pointer-events-none z-20">
          <span className={`text-sm font-bold powerup-float ${
            effectText.startsWith('+') ? 'text-green-400' :
            effectText.startsWith('-') ? 'text-red-400' : 'text-yellow-300'
          }`}>
            {effectText}
          </span>
        </div>
      )}

      {/* Drop target indicator */}
      {isDropTarget && (
        <div className="absolute inset-0 -m-4 rounded-2xl border-4 border-dashed border-yellow-400 drop-zone-pulse z-10" />
      )}

      {/* Sleep indicator */}
      {monster.sleepTurns > 0 && (
        <div className="absolute top-0 right-0 text-lg z-10">üí§</div>
      )}

      {/* Monster with colored glow background */}
      <div className="relative">
        {/* Colored glow circle behind monster */}
        <div className={`absolute inset-0 -m-2 rounded-full ${monster.color.bg} opacity-40 blur-xl`} />

        {/* Boost effect */}
        {boostEffect && (
          <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
            <span className="text-2xl powerup-float">‚ú®</span>
          </div>
        )}

        <div
          className={`relative text-6xl transition-all duration-200 ${monster.color.glow} monster-glow ${
            isAttacking ? (isLeft ? 'attack-right' : 'attack-left') :
            isHit ? (isCriticalHit ? (isLeft ? 'crit-hit-right shake' : 'crit-hit-left shake') : (isLeft ? 'hit-right shake' : 'hit-left shake')) :
            isWinner ? (isLeft ? 'float-flipped' : 'float') :
            isLeft ? 'scale-x-[-1]' : ''
          } ${boostEffect ? 'boost-pulse' : ''} ${isCritAttacker ? 'crit-attacker-glow' : ''}`}
          style={{
            filter: monster.hp <= 0 ? 'grayscale(1) opacity(0.5)' :
                   monster.sleepTurns > 0 ? 'brightness(0.7)' : undefined,
            transform: (!isAttacking && !isHit && !isWinner && isLeft) ? 'scaleX(-1)' : undefined
          }}
        >
          {monster.emoji}
        </div>
      </div>

      {/* Health bar */}
      <div className={`w-24 h-3 bg-black/40 rounded-full overflow-hidden mt-3 ring-2 ${monster.color.ring}`}>
        <div
          className={`health-bar h-full rounded-full ${
            monster.hp > 50 ? 'bg-gradient-to-r from-green-400 to-green-500' :
            monster.hp > 25 ? 'bg-gradient-to-r from-yellow-400 to-orange-500' :
            'bg-gradient-to-r from-red-500 to-red-600'
          }`}
          style={{ width: `${Math.max(0, monster.hp)}%` }}
        />
      </div>
      <p className="text-white text-sm font-bold mt-1">{Math.max(0, Math.round(monster.hp))} HP</p>

      {/* Monster name plate - below health */}
      <div className={`text-center mt-1 px-3 py-1 rounded-lg ${monster.color.bg} shadow-lg`}>
        <p className="text-white text-xs font-bold truncate max-w-[100px]" title={monster.choice}>
          "{monster.choice}"
        </p>
      </div>

      {/* Active effects bar - fixed height to prevent layout shift */}
      <div className="h-5 mt-1 flex items-center justify-center">
        {activeEffects && activeEffects.length > 0 && (
          <div className="flex gap-0.5 bg-black/30 rounded-full px-1.5 py-0.5">
            {activeEffects.map((effect, idx) => (
              <span key={idx} className="text-xs" title={effect.name}>{effect.emoji}</span>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}

// Draggable Item Component
function DraggableItem({ item, onDragStart, onDragEnd, isTouchDragging }) {
  const handleDragStart = (e) => {
    onDragStart(item, e);
  };

  const handleTouchStart = (e) => {
    e.preventDefault();
    e.stopPropagation();
    const touch = e.touches[0];
    onDragStart(item, { clientX: touch.clientX, clientY: touch.clientY, type: 'touch' });
  };

  const isBeingDragged = isTouchDragging === item.id;

  return (
    <div
      draggable
      onDragStart={handleDragStart}
      onDragEnd={onDragEnd}
      onTouchStart={handleTouchStart}
      className={`draggable-item flex flex-col items-center justify-center rounded-xl bg-gradient-to-br ${item.color}
        shadow-lg border-2 border-white/20 ${item.isNew ? 'item-spawn' : 'item-wobble'}
        ${isBeingDragged ? 'opacity-40' : 'hover:scale-105'} transition-transform`}
      style={{ width: 56, height: 56 }}
    >
      <span className="text-lg leading-none">{item.emoji}</span>
      <span className="text-[9px] text-white font-bold leading-tight">{item.label}</span>
      <span className="text-[9px] text-white/80 leading-tight">+{item.value}</span>
    </div>
  );
}

function App() {
  const { ShareCardFooter } = window;
  const [stage, setStage] = useState('input'); // input, intro, battle, result
  const [choices, setChoices] = useState(['', '']);
  const [monsters, setMonsters] = useState([null, null]);
  const [battleLog, setBattleLog] = useState([]);
  const [itemsUsed, setItemsUsed] = useState([[], []]); // Track items used on each monster (for analysis)
  const [activeEffects, setActiveEffects] = useState([[], []]); // Temporary display of active effects
  const [round, setRound] = useState(0);
  const [attackingMonster, setAttackingMonster] = useState(null);
  const [hitMonster, setHitMonster] = useState(null);
  const [winner, setWinner] = useState(null);
  const [boostEffect, setBoostEffect] = useState([false, false]);
  const [effectTexts, setEffectTexts] = useState([null, null]);
  const lastInteractionRef = useRef(Date.now());
  const [history, setHistory] = useState([]);
  const [showHistory, setShowHistory] = useState(false);
  const [shareStatus, setShareStatus] = useState(null);
  const [showConfetti, setShowConfetti] = useState(false);
  const [items, setItems] = useState([]);
  const [draggedItem, setDraggedItem] = useState(null);
  const [dropTarget, setDropTarget] = useState(null);
  const [dragPosition, setDragPosition] = useState(null);
  const [isCritical, setIsCritical] = useState(false);
  const [screenShake, setScreenShake] = useState(false);
  const [damageText, setDamageText] = useState(null); // { monsterIndex, amount, isCrit }
  const [critAttacker, setCritAttacker] = useState(null); // Which monster landed the crit
  const [replayCount, setReplayCount] = useState(0); // Track how many times user replayed
  const shareCardRef = useRef(null);
  const monster0Ref = useRef(null);
  const monster1Ref = useRef(null);

  // Refs to track current drag state for touch handlers (avoids stale closures)
  const draggedItemRef = useRef(null);
  const dropTargetRef = useRef(null);

  // Initialize items when battle starts
  const initializeItems = () => {
    setItems([generateItem(), generateItem(), generateItem(), generateItem(), generateItem()]);
  };

  // Regenerate an item after use (only if there's room)
  useEffect(() => {
    if (stage === 'battle' && winner === null && items.length < MAX_SHELF_ITEMS) {
      const timer = setTimeout(() => {
        setItems(prev => {
          if (prev.length >= MAX_SHELF_ITEMS) return prev;
          return [...prev, generateItem()];
        });
      }, 800);
      return () => clearTimeout(timer);
    }
  }, [items.length, stage, winner]);

  // Discard all items
  const discardAllItems = () => {
    recordInteraction();
    setItems([]);
  };

  const shareResults = async () => {
    if (!shareCardRef.current || winner === null) return;
    setShareStatus('generating');

    try {
      const canvas = await html2canvas(shareCardRef.current, {
        backgroundColor: null,
        scale: 2,
        logging: false,
      });

      const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
      const file = new File([blob], 'battle-result.png', { type: 'image/png' });
      const analysis = getAnalysis();

      if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
        await navigator.share({
          files: [file],
          title: 'Decision Battle Results',
          text: `"${choices[winner]}" beats "${choices[1 - winner]}"!`,
        });
        setShareStatus('shared');
      } else {
        // Download image when file sharing not supported
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'battle-result.png';
        a.click();
        URL.revokeObjectURL(url);
        setShareStatus('downloaded');
      }
    } catch (err) {
      if (err.name !== 'AbortError') {
        const text = `"${choices[winner]}" beats "${choices[1 - winner]}"!\nMade with Marco's Decision Tools`;
        await navigator.clipboard.writeText(text);
        setShareStatus('copied');
      } else {
        setShareStatus(null);
        return;
      }
    }
    setTimeout(() => setShareStatus(null), 2500);
  };

  const getShareButtonText = () => {
    switch (shareStatus) {
      case 'generating': return '...';
      case 'shared': return 'Shared';
      case 'downloaded': return 'Saved';
      case 'copied': return 'Copied';
      default: return 'Share';
    }
  };

  useEffect(() => {
    setHistory(loadHistory());
  }, []);

  const addLog = useCallback((message, type = 'normal') => {
    setBattleLog(prev => [...prev.slice(-4), { message, type, id: Date.now() }]);
  }, []);

  const startBattle = () => {
    if (choices[0].trim().length < 1 || choices[1].trim().length < 1) {
      alert('Please enter both choices');
      return;
    }

    const trimmedChoices = [choices[0].trim(), choices[1].trim()];
    saveToHistory(trimmedChoices);
    setHistory(loadHistory());

    const m1 = generateMonster(trimmedChoices[0], 0);
    const m2 = generateMonster(trimmedChoices[1], 1);
    setMonsters([m1, m2]);
    setStage('intro');
  };

  const loadFromHistory = (entry) => {
    setChoices(entry.choices);
    setShowHistory(false);
  };

  const handleDeleteHistory = (id, e) => {
    e.stopPropagation();
    deleteFromHistory(id);
    setHistory(loadHistory());
  };

  const recordInteraction = () => {
    lastInteractionRef.current = Date.now();
  };

  const getDynamicSpeed = () => {
    const SPEED_FAST = 350;
    const SPEED_SLOW = 1400;
    const DECAY_MS = 4000;
    const elapsed = Date.now() - lastInteractionRef.current;
    const t = Math.min(elapsed / DECAY_MS, 1);
    const eased = t * t; // quadratic ease ‚Äî slow at first, then speeds up
    return SPEED_SLOW + (SPEED_FAST - SPEED_SLOW) * eased;
  };

  const beginFight = () => {
    lastInteractionRef.current = Date.now();
    setStage('battle');
    initializeItems();
    addLog('Battle begins! Drag items onto monsters!', 'announcement');
    setRound(1);
  };

  // Handle drag start (both mouse and touch)
  const handleDragStart = (item, e) => {
    recordInteraction();
    setDraggedItem(item);
    draggedItemRef.current = item;
    if (e.type === 'touch') {
      setDragPosition({ x: e.clientX, y: e.clientY });
    }
  };

  // Handle drag end (mouse only - touch is handled in useEffect)
  const handleDragEnd = () => {
    if (draggedItem && dropTarget !== null) {
      applyItemToMonster(draggedItem, dropTarget);
    }
    setDraggedItem(null);
    setDropTarget(null);
    setDragPosition(null);
    draggedItemRef.current = null;
    dropTargetRef.current = null;
  };

  // Touch move handler for mobile drag
  useEffect(() => {
    if (!draggedItem || stage !== 'battle') return;

    const handleTouchMove = (e) => {
      e.preventDefault(); // Prevent scrolling while dragging
      recordInteraction();
      const touch = e.touches[0];
      setDragPosition({ x: touch.clientX, y: touch.clientY });

      // Check if over a monster
      const checkDropTarget = (ref) => {
        if (!ref.current) return false;
        const rect = ref.current.getBoundingClientRect();
        return touch.clientX >= rect.left && touch.clientX <= rect.right &&
               touch.clientY >= rect.top && touch.clientY <= rect.bottom;
      };

      let newTarget = null;
      if (checkDropTarget(monster0Ref)) {
        newTarget = 0;
      } else if (checkDropTarget(monster1Ref)) {
        newTarget = 1;
      }
      setDropTarget(newTarget);
      dropTargetRef.current = newTarget;
    };

    const handleTouchEnd = (e) => {
      e.preventDefault();
      // Use refs to get current values (avoids stale closure)
      const currentItem = draggedItemRef.current;
      const currentTarget = dropTargetRef.current;

      // Apply item if dropped on a target
      if (currentItem && currentTarget !== null) {
        applyItemToMonster(currentItem, currentTarget);
      }
      // Reset drag state
      setDraggedItem(null);
      setDropTarget(null);
      setDragPosition(null);
      draggedItemRef.current = null;
      dropTargetRef.current = null;
    };

    const handleTouchCancel = () => {
      setDraggedItem(null);
      setDropTarget(null);
      setDragPosition(null);
      draggedItemRef.current = null;
      dropTargetRef.current = null;
    };

    window.addEventListener('touchmove', handleTouchMove, { passive: false });
    window.addEventListener('touchend', handleTouchEnd, { passive: false });
    window.addEventListener('touchcancel', handleTouchCancel);

    return () => {
      window.removeEventListener('touchmove', handleTouchMove);
      window.removeEventListener('touchend', handleTouchEnd);
      window.removeEventListener('touchcancel', handleTouchCancel);
    };
  }, [draggedItem, stage]);

  // Apply item effect to monster
  const applyItemToMonster = (item, monsterIndex) => {
    recordInteraction();
    if (stage !== 'battle' || winner !== null) return;

    const effectId = `${item.id}-${Date.now()}`;

    // Track item usage (for analysis)
    setItemsUsed(prev => {
      const newUsed = [...prev];
      newUsed[monsterIndex] = [...newUsed[monsterIndex], item];
      return newUsed;
    });

    // Remove item from shelf
    setItems(prev => prev.filter(i => i.id !== item.id));

    // Show effect text
    let effectText = '';

    // Duration for showing effect icon (immediate effects shorter, buffs longer)
    const isImmediate = ['heal', 'damage'].includes(item.effect);
    const displayDuration = isImmediate ? 1500 : 3000;

    // Add to active effects display
    setActiveEffects(prev => {
      const newEffects = [...prev];
      newEffects[monsterIndex] = [...newEffects[monsterIndex], { id: effectId, emoji: item.emoji, name: item.name, effect: item.effect }];
      return newEffects;
    });

    // Remove from display after duration (sleep is handled separately when sleepTurns reaches 0)
    if (item.effect !== 'sleep') {
      setTimeout(() => {
        setActiveEffects(prev => {
          const newEffects = [...prev];
          newEffects[monsterIndex] = newEffects[monsterIndex].filter(e => e.id !== effectId);
          return newEffects;
        });
      }, displayDuration);
    }

    // Apply effect
    let wasLethal = false;
    setMonsters(prev => {
      const newMonsters = [...prev];
      const target = { ...newMonsters[monsterIndex] };

      switch (item.effect) {
        case 'heal':
          target.hp = Math.min(target.maxHp, target.hp + item.value);
          effectText = `+${item.value} HP`;
          addLog(`${item.emoji} ${target.fullName} healed for ${item.value} HP!`, 'boost');
          break;
        case 'attack':
          target.attack += item.value;
          effectText = `+${item.value} ATK`;
          addLog(`${item.emoji} ${target.fullName} gained ${item.value} attack!`, 'boost');
          break;
        case 'defense':
          target.defense += item.value;
          effectText = `+${item.value} DEF`;
          addLog(`${item.emoji} ${target.fullName} gained ${item.value} defense!`, 'boost');
          break;
        case 'damage':
          target.hp -= item.value;
          effectText = `-${item.value} HP`;
          addLog(`${item.emoji} ${target.fullName} took ${item.value} poison damage!`, 'damage');
          // Check if this kills the target
          if (target.hp <= 0) {
            wasLethal = true;
          }
          break;
        case 'sleep':
          target.sleepTurns += item.value;
          effectText = `üí§ ${item.value}`;
          addLog(`${item.emoji} ${target.fullName} fell asleep for ${item.value} turns!`, 'status');
          break;
      }

      newMonsters[monsterIndex] = target;

      // Handle lethal damage - declare winner
      if (wasLethal) {
        const winnerIndex = 1 - monsterIndex;
        setTimeout(() => {
          setWinner(winnerIndex);
          setShowConfetti(true);
          setStage('result');
          addLog(`${newMonsters[winnerIndex].fullName} wins!`, 'victory');
        }, 400);
      }

      return newMonsters;
    });

    // Show effect text
    setEffectTexts(prev => {
      const newTexts = [...prev];
      newTexts[monsterIndex] = effectText;
      return newTexts;
    });
    setTimeout(() => {
      setEffectTexts(prev => {
        const newTexts = [...prev];
        newTexts[monsterIndex] = null;
        return newTexts;
      });
    }, 800);

    // Visual boost effect
    setBoostEffect(prev => {
      const newEffect = [...prev];
      newEffect[monsterIndex] = true;
      return newEffect;
    });
    setTimeout(() => {
      setBoostEffect(prev => {
        const newEffect = [...prev];
        newEffect[monsterIndex] = false;
        return newEffect;
      });
    }, 300);
  };

  // Battle loop
  useEffect(() => {
    if (stage !== 'battle' || round === 0 || winner !== null) return;

    // Check if any monster is already defeated
    if (monsters[0]?.hp <= 0 || monsters[1]?.hp <= 0) return;

    const executeAttack = () => {
      const attacker = round % 2 === 1 ? 0 : 1;
      const defender = 1 - attacker;

      // Check if attacker is asleep
      if (monsters[attacker]?.sleepTurns > 0) {
        const newSleepTurns = monsters[attacker].sleepTurns - 1;
        setMonsters(prev => {
          const newMonsters = [...prev];
          newMonsters[attacker] = {
            ...newMonsters[attacker],
            sleepTurns: newSleepTurns
          };
          return newMonsters;
        });
        // Remove sleep effect from display when it wears off
        if (newSleepTurns === 0) {
          setActiveEffects(prev => {
            const newEffects = [...prev];
            newEffects[attacker] = newEffects[attacker].filter(e => e.effect !== 'sleep');
            return newEffects;
          });
        }
        addLog(`${monsters[attacker].fullName} is asleep! üí§`);
        return;
      }

      setAttackingMonster(attacker);

      // Roll for miss (10% chance) or critical hit (15% chance)
      const missRoll = Math.random();
      const isMiss = missRoll < 0.10;
      const isCrit = !isMiss && missRoll > 0.85; // 15% crit chance (0.85-1.0)

      setTimeout(() => {
        if (isMiss) {
          // Attack missed!
          setDamageText({ monsterIndex: defender, amount: 0, isMiss: true });
          addLog(`${monsters[attacker].fullName} missed!`, 'miss');

          setTimeout(() => {
            setAttackingMonster(null);
            setDamageText(null);
          }, 600);
          return;
        }

        setHitMonster(defender);
        if (isCrit) {
          setIsCritical(true);
          setScreenShake(true);
          setCritAttacker(attacker);
        }

        setMonsters(prev => {
          let damage = Math.max(1, prev[attacker].attack - prev[defender].defense + Math.floor(Math.random() * 5));

          // Double damage on crit
          if (isCrit) {
            damage = Math.floor(damage * 2);
          }

          // Show damage number floating up from the hit monster
          setDamageText({ monsterIndex: defender, amount: Math.round(damage), isCrit });

          const newMonsters = [...prev];
          newMonsters[defender] = {
            ...newMonsters[defender],
            hp: newMonsters[defender].hp - damage
          };

          if (isCrit) {
            addLog(`üí• CRITICAL HIT! ${prev[attacker].fullName} deals ${Math.round(damage)} damage!`, 'critical');
          } else {
            addLog(`${prev[attacker].fullName} deals ${Math.round(damage)} damage!`);
          }

          // Check for winner
          if (newMonsters[defender].hp <= 0) {
            setTimeout(() => {
              setWinner(attacker);
              setShowConfetti(true);
              setStage('result');
              addLog(`${prev[attacker].fullName} wins!`, 'victory');
            }, 400);
          }

          return newMonsters;
        });

        setTimeout(() => {
          setAttackingMonster(null);
          setHitMonster(null);
          setIsCritical(false);
          setScreenShake(false);
          setCritAttacker(null);
        }, isCrit ? 500 : 300);

        // Clear damage text after animation completes
        setTimeout(() => {
          setDamageText(null);
        }, 800);
      }, 200);
    };

    const speed = getDynamicSpeed();
    const timer = setTimeout(() => {
      executeAttack();
      // Only increment round if no monster is defeated
      if (winner === null && monsters[0]?.hp > 0 && monsters[1]?.hp > 0) {
        setRound(prev => prev + 1);
      }
    }, speed);

    return () => clearTimeout(timer);
  }, [round, stage, winner, monsters]);

  const getAnalysis = () => {
    const counts = [itemsUsed[0].length, itemsUsed[1].length];
    const total = counts[0] + counts[1];
    if (total === 0) return null;

    // Count helpful vs harmful items per monster
    const helpful0 = itemsUsed[0].filter(i => ['heal', 'attack', 'defense'].includes(i.effect)).length;
    const helpful1 = itemsUsed[1].filter(i => ['heal', 'attack', 'defense'].includes(i.effect)).length;
    const harmful0 = itemsUsed[0].filter(i => ['damage', 'sleep'].includes(i.effect)).length;
    const harmful1 = itemsUsed[1].filter(i => ['damage', 'sleep'].includes(i.effect)).length;

    // Net support = helpful items on self - harmful items received
    const support0 = helpful0;
    const support1 = helpful1;

    const favoredIndex = support0 > support1 ? 0 : support1 > support0 ? 1 : null;
    const favoredPercent = favoredIndex !== null
      ? Math.round((Math.max(support0, support1) / (support0 + support1 || 1)) * 100)
      : 50;

    return {
      favoredIndex,
      favoredChoice: favoredIndex !== null ? choices[favoredIndex] : null,
      itemCounts: counts,
      helpfulCounts: [helpful0, helpful1],
      harmfulCounts: [harmful0, harmful1],
      total,
      favoredPercent,
      isTie: support0 === support1,
    };
  };

  const reset = () => {
    setStage('input');
    setChoices(['', '']);
    setMonsters([null, null]);
    setBattleLog([]);
    setItemsUsed([[], []]);
    setActiveEffects([[], []]);
    setRound(0);
    setAttackingMonster(null);
    setHitMonster(null);
    setWinner(null);
    setBoostEffect([false, false]);
    setItems([]);
    setShowConfetti(false);
    setIsCritical(false);
    setScreenShake(false);
    setCritAttacker(null);
    setDamageText(null);
    setReplayCount(0);
  };

  return (
    <div className="h-full bg-gradient-to-br from-slate-900 via-red-950 to-slate-900 p-4 flex items-center justify-center overflow-auto">
      <Confetti show={showConfetti} />

      {/* Floating dragged item for touch */}
      {draggedItem && dragPosition && (
        <div
          className="fixed pointer-events-none z-50"
          style={{
            left: dragPosition.x - 28,
            top: dragPosition.y - 28,
          }}
        >
          <div className={`w-[56px] h-[56px] flex flex-col items-center justify-center rounded-xl bg-gradient-to-br ${draggedItem.color} shadow-2xl border-2 border-white/50 scale-110`}>
            <span className="text-lg">{draggedItem.emoji}</span>
            <span className="text-[9px] text-white font-bold">{draggedItem.label}</span>
          </div>
        </div>
      )}

      <a href="/my-tools/" className="absolute top-4 left-4 p-2 bg-white/10 hover:bg-white/20 rounded-full transition-colors z-10">
        <svg className="w-5 h-5 text-red-200" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
        </svg>
      </a>

      <div className="w-full max-w-md my-auto pt-12">
        {stage === 'input' && (
          <div className="bg-slate-800/80 backdrop-blur rounded-2xl shadow-2xl p-6 border border-red-500/30">
            <div className="text-center mb-6">
              <span className="text-4xl">‚öîÔ∏è</span>
              <h1 className="text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-red-400 to-orange-400 mt-2">
                Decision Battle
              </h1>
              <p className="text-red-200/70 text-sm mt-1">
                Your choices become monsters. Your heart decides the winner.
              </p>
            </div>

            <div className="space-y-4">
              <div>
                <label className="text-red-200/80 text-sm mb-1 block">First Choice</label>
                <input
                  type="text"
                  value={choices[0]}
                  onChange={(e) => setChoices([e.target.value, choices[1]])}
                  placeholder="e.g., Take the job"
                  className="w-full p-3 bg-slate-700/50 border border-red-500/30 rounded-xl text-red-100 placeholder-red-300/40 focus:outline-none focus:ring-2 focus:ring-red-500/50"
                  maxLength={30}
                />
              </div>

              <div className="text-center text-red-400 font-bold">VS</div>

              <div>
                <label className="text-red-200/80 text-sm mb-1 block">Second Choice</label>
                <input
                  type="text"
                  value={choices[1]}
                  onChange={(e) => setChoices([choices[0], e.target.value])}
                  placeholder="e.g., Stay where I am"
                  className="w-full p-3 bg-slate-700/50 border border-red-500/30 rounded-xl text-red-100 placeholder-red-300/40 focus:outline-none focus:ring-2 focus:ring-red-500/50"
                  maxLength={30}
                />
              </div>
            </div>

            {history.length > 0 && (
              <div className="mt-4">
                <button
                  onClick={() => setShowHistory(!showHistory)}
                  className="text-sm text-red-400 hover:text-red-300 flex items-center gap-1"
                >
                  {showHistory ? 'Hide' : 'Load'} previous battles ({history.length})
                  <svg className={`w-4 h-4 transition-transform ${showHistory ? 'rotate-180' : ''}`} fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                  </svg>
                </button>
                {showHistory && (
                  <div className="mt-2 space-y-2 max-h-32 overflow-y-auto">
                    {history.map(entry => (
                      <div
                        key={entry.id}
                        onClick={() => loadFromHistory(entry)}
                        className="flex items-center justify-between p-2 bg-slate-700/50 hover:bg-red-900/30 rounded-lg cursor-pointer border border-red-500/20"
                      >
                        <div className="flex-1 min-w-0">
                          <p className="text-sm text-red-200 truncate">{entry.preview}</p>
                          <p className="text-xs text-red-400/50">{entry.date}</p>
                        </div>
                        <button
                          onClick={(e) => handleDeleteHistory(entry.id, e)}
                          className="ml-2 p-2 min-w-[44px] min-h-[44px] flex items-center justify-center text-red-400/70 hover:text-red-400 hover:bg-red-900/30 rounded-lg transition-colors"
                        >
                          <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2.5}>
                            <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
                          </svg>
                        </button>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            )}

            <div className="mt-4 p-3 bg-red-900/30 rounded-xl text-sm text-red-200/70">
              <p className="font-medium text-red-200 mb-1">‚öîÔ∏è How to play:</p>
              <p>Drag potions and spells onto the monsters during battle! Help one win to reveal your true preference.</p>
            </div>

            <button
              onClick={startBattle}
              className="w-full mt-6 py-3 bg-gradient-to-r from-red-600 to-orange-600 hover:from-red-500 hover:to-orange-500 text-white font-bold rounded-xl transition-all shadow-lg shadow-red-500/25"
            >
              Summon the Monsters! ‚öîÔ∏è
            </button>
          </div>
        )}

        {stage === 'intro' && monsters[0] && monsters[1] && (
          <div className="bg-slate-800/80 backdrop-blur rounded-2xl shadow-2xl p-6 border border-red-500/30">
            <h2 className="text-xl font-bold text-center text-red-200 mb-6">The Combatants</h2>

            <div className="flex justify-around items-center mb-6">
              <Monster monster={monsters[0]} isLeft={true} />
              <div className="text-3xl text-red-400 font-bold px-2">VS</div>
              <Monster monster={monsters[1]} isLeft={false} />
            </div>

            <div className="space-y-2 mb-6 text-center">
              <p className="text-red-200/80 text-sm">
                <span className="font-semibold">{monsters[0].fullName}</span>
              </p>
              <p className="text-red-300/50 text-xs">vs</p>
              <p className="text-red-200/80 text-sm">
                <span className="font-semibold">{monsters[1].fullName}</span>
              </p>
            </div>

            <div className="p-3 bg-amber-900/30 rounded-xl text-sm text-amber-200/80 mb-4">
              <p className="font-medium text-amber-200 mb-2 text-center">üéÆ Battle Controls</p>
              <div className="flex justify-center gap-3 flex-wrap">
                <span className="inline-flex items-center gap-1"><span className="text-lg">üß™</span> Heal</span>
                <span className="inline-flex items-center gap-1"><span className="text-lg">‚ö°</span> Power</span>
                <span className="inline-flex items-center gap-1"><span className="text-lg">üõ°Ô∏è</span> Shield</span>
                <span className="inline-flex items-center gap-1"><span className="text-lg">‚ò†Ô∏è</span> Poison</span>
                <span className="inline-flex items-center gap-1"><span className="text-lg">üí§</span> Sleep</span>
              </div>
              <p className="text-xs text-amber-200/60 mt-2 text-center">Drag items onto monsters to help or hinder them!</p>
            </div>

            <button
              onClick={beginFight}
              className="w-full py-3 bg-gradient-to-r from-red-600 to-orange-600 hover:from-red-500 hover:to-orange-500 text-white font-bold rounded-xl transition-all shadow-lg shadow-red-500/50"
            >
              Begin Battle!
            </button>
          </div>
        )}

        {stage === 'battle' && monsters[0] && monsters[1] && (
          <div className={`bg-slate-800/80 backdrop-blur rounded-2xl shadow-2xl p-4 border border-red-500/30 relative overflow-hidden ${screenShake ? 'screen-shake' : ''}`}>
            {/* Critical hit flash overlay */}
            {isCritical && (
              <div className="absolute inset-0 bg-yellow-400 crit-flash pointer-events-none z-20" />
            )}

            <div className="text-center mb-2">
              <span className="text-red-400 text-sm font-medium">Round {round}</span>
              <span className="text-red-400/50 text-xs ml-3">
                Items: {itemsUsed[0].length} vs {itemsUsed[1].length}
              </span>
            </div>

            {/* Battle arena */}
            <div className="flex justify-around items-center mb-3">
              <div
                ref={monster0Ref}
                className="p-2 rounded-2xl transition-colors"
                style={{ background: dropTarget === 0 ? 'rgba(250, 204, 21, 0.2)' : 'transparent' }}
                onDragOver={(e) => { e.preventDefault(); setDropTarget(0); }}
                onDragLeave={() => setDropTarget(null)}
                onDrop={() => handleDragEnd()}
              >
                <Monster
                  monster={monsters[0]}
                  isLeft={true}
                  isAttacking={attackingMonster === 0}
                  isHit={hitMonster === 0}
                  isCriticalHit={isCritical && hitMonster === 0}
                  isCritAttacker={critAttacker === 0}
                  boostEffect={boostEffect[0]}
                  isDropTarget={dropTarget === 0}
                  effectText={effectTexts[0]}
                  activeEffects={activeEffects[0]}
                  damageText={damageText?.monsterIndex === 0 ? damageText : null}
                />
              </div>

              <div className="text-2xl text-red-400 font-bold">‚öîÔ∏è</div>

              <div
                ref={monster1Ref}
                className="p-2 rounded-2xl transition-colors"
                style={{ background: dropTarget === 1 ? 'rgba(250, 204, 21, 0.2)' : 'transparent' }}
                onDragOver={(e) => { e.preventDefault(); setDropTarget(1); }}
                onDragLeave={() => setDropTarget(null)}
                onDrop={() => handleDragEnd()}
              >
                <Monster
                  monster={monsters[1]}
                  isLeft={false}
                  isAttacking={attackingMonster === 1}
                  isHit={hitMonster === 1}
                  isCriticalHit={isCritical && hitMonster === 1}
                  isCritAttacker={critAttacker === 1}
                  boostEffect={boostEffect[1]}
                  isDropTarget={dropTarget === 1}
                  effectText={effectTexts[1]}
                  activeEffects={activeEffects[1]}
                  damageText={damageText?.monsterIndex === 1 ? damageText : null}
                />
              </div>
            </div>

            {/* Item Shelf */}
            <div className="bg-gradient-to-b from-amber-900/50 to-amber-950/50 rounded-xl p-3 mb-3 border border-amber-600/30">
              <div className="flex items-center justify-between mb-2">
                <div className="text-amber-300/80 text-xs font-medium">
                  ‚¨áÔ∏è Drag onto monsters
                </div>
                <button
                  onClick={discardAllItems}
                  className="text-[10px] px-2 py-1 bg-red-900/50 hover:bg-red-800/50 text-red-300 rounded transition-colors"
                  disabled={items.length === 0}
                >
                  üóëÔ∏è Discard
                </button>
              </div>
              <div className="flex justify-center gap-1">
                {Array.from({ length: MAX_SHELF_ITEMS }).map((_, idx) => {
                  const item = items[idx];
                  return item ? (
                    <DraggableItem
                      key={item.id}
                      item={item}
                      onDragStart={handleDragStart}
                      onDragEnd={handleDragEnd}
                      isTouchDragging={draggedItem?.id}
                    />
                  ) : (
                    <div
                      key={`empty-${idx}`}
                      className="w-[56px] h-[56px] rounded-xl border-2 border-dashed border-amber-600/30 flex items-center justify-center"
                      style={{ background: 'rgba(0,0,0,0.2)' }}
                    >
                      <span className="text-amber-600/30 text-lg">?</span>
                    </div>
                  );
                })}
              </div>
            </div>

            {/* Battle log */}
            <div className="h-14 overflow-y-auto bg-black/30 rounded-lg p-2 text-xs">
              {battleLog.map(log => (
                <p
                  key={log.id}
                  className={`${
                    log.type === 'announcement' ? 'text-yellow-300 font-bold' :
                    log.type === 'critical' ? 'text-yellow-400 font-bold' :
                    log.type === 'miss' ? 'text-cyan-400' :
                    log.type === 'boost' ? 'text-green-300' :
                    log.type === 'damage' ? 'text-red-300' :
                    log.type === 'status' ? 'text-blue-300' :
                    log.type === 'victory' ? 'text-green-400 font-bold' :
                    'text-red-200/80'
                  }`}
                >
                  {log.message}
                </p>
              ))}
            </div>
          </div>
        )}

        {stage === 'result' && winner !== null && (
          <div className="bg-slate-800/80 backdrop-blur rounded-2xl shadow-2xl p-6 border border-red-500/30">
            {/* Hidden share card - Instagram optimized 1080x1080 (540x540 * scale 2) */}
            <div style={{ position: 'absolute', left: '-9999px', top: 0 }}>
              <div
                ref={shareCardRef}
                style={{
                  width: 540,
                  height: 540,
                  padding: 32,
                  background: 'linear-gradient(135deg, #1e293b 0%, #450a0a 50%, #1e293b 100%)',
                  fontFamily: 'Arial, Helvetica, sans-serif',
                  boxSizing: 'border-box',
                  position: 'relative',
                }}
              >
                {/* Header */}
                <div style={{ textAlign: 'center', marginBottom: 12 }}>
                  <div style={{ fontSize: 14, lineHeight: '18px', color: '#94a3b8', letterSpacing: 2 }}>{'DECISION BATTLE'}</div>
                </div>

                {/* Monsters face-off */}
                <div style={{ textAlign: 'center', marginBottom: 8 }}>
                  <span style={{ fontSize: 56, opacity: winner === 0 ? 1 : 0.5, verticalAlign: 'middle' }}>{monsters[0].emoji}</span>
                  <span style={{ fontSize: 32, color: '#ef4444', verticalAlign: 'middle', margin: '0 12px' }}>{'‚öîÔ∏è'}</span>
                  <span style={{ fontSize: 56, opacity: winner === 1 ? 1 : 0.5, verticalAlign: 'middle' }}>{monsters[1].emoji}</span>
                </div>

                {/* HP display */}
                <div style={{ display: 'flex', justifyContent: 'center', gap: 60, marginBottom: 20 }}>
                  <div style={{
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    fontSize: 12,
                    color: winner === 0 ? '#fbbf24' : '#64748b',
                    background: 'rgba(0,0,0,0.3)',
                    borderRadius: 12,
                    padding: '4px 14px',
                    height: 28,
                  }}>
                    {Math.max(0, Math.round(monsters[0].hp))}{' HP'}
                  </div>
                  <div style={{
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    fontSize: 12,
                    color: winner === 1 ? '#fbbf24' : '#64748b',
                    background: 'rgba(0,0,0,0.3)',
                    borderRadius: 12,
                    padding: '4px 14px',
                    height: 28,
                  }}>
                    {Math.max(0, Math.round(monsters[1].hp))}{' HP'}
                  </div>
                </div>

                {/* Winner announcement */}
                <div style={{ textAlign: 'center', marginBottom: 20 }}>
                  <div style={{ fontSize: 28, lineHeight: '34px', fontWeight: 'bold', color: '#fbbf24', marginBottom: 6 }}>{'üèÜ Victory!'}</div>
                  <div style={{ fontSize: 22, lineHeight: '28px', color: '#ffffff', fontWeight: 'bold', marginBottom: 4 }}>{'"'}{choices[winner]}{'"'}</div>
                  <div style={{ fontSize: 14, lineHeight: '20px', color: '#94a3b8' }}>{'defeats "'}{choices[1 - winner]}{'"'}</div>
                </div>

                {/* Battle stats row */}
                <div style={{
                  display: 'flex',
                  justifyContent: 'center',
                  marginBottom: 16,
                }}>
                  <div style={{
                    display: 'flex',
                    background: 'rgba(0,0,0,0.4)',
                    borderRadius: 12,
                    padding: '8px 12px',
                  }}>
                    <div style={{ padding: '4px 16px', textAlign: 'center' }}>
                      <div style={{ fontSize: 22, lineHeight: '26px', color: '#fbbf24', fontWeight: 'bold' }}>{round}</div>
                      <div style={{ fontSize: 11, lineHeight: '14px', color: '#94a3b8' }}>{'rounds'}</div>
                    </div>
                    <div style={{ padding: '4px 16px', textAlign: 'center' }}>
                      <div style={{ fontSize: 22, lineHeight: '26px', color: '#fbbf24', fontWeight: 'bold' }}>{itemsUsed[0].length + itemsUsed[1].length}</div>
                      <div style={{ fontSize: 11, lineHeight: '14px', color: '#94a3b8' }}>{'items'}</div>
                    </div>
                    {replayCount > 0 && (
                      <div style={{ padding: '4px 16px', textAlign: 'center' }}>
                        <div style={{ fontSize: 22, lineHeight: '26px', color: '#fbbf24', fontWeight: 'bold' }}>{replayCount}</div>
                        <div style={{ fontSize: 11, lineHeight: '14px', color: '#94a3b8' }}>{replayCount === 1 ? 'replay' : 'replays'}</div>
                      </div>
                    )}
                  </div>
                </div>

                {/* Heart analysis or passive message */}
                <div style={{ textAlign: 'center', marginBottom: 16 }}>
                  {(() => {
                    const analysis = getAnalysis();
                    if (!analysis) {
                      const winMargin = Math.round(monsters[winner].hp);
                      const battleDescription = winMargin > 50 ? 'Dominant victory! ' :
                        winMargin > 25 ? 'A solid win. ' :
                        winMargin > 10 ? 'A close battle! ' : 'Photo finish! ';
                      return (
                        <div style={{ color: '#94a3b8', fontSize: 14, lineHeight: '20px', fontStyle: 'italic' }}>
                          {battleDescription}{'Let fate decide.'}
                        </div>
                      );
                    }

                    return (
                      <>
                        <div style={{ fontSize: 12, lineHeight: '16px', color: '#c4b5fd', marginBottom: 6 }}>{'My heart revealed:'}</div>
                        <div style={{ fontSize: 14, lineHeight: '20px', color: '#e9d5ff', fontWeight: 'bold' }}>
                          {analysis.isTie
                            ? 'Helped both equally'
                            : 'Favored "' + analysis.favoredChoice + '" (' + analysis.favoredPercent + '%)'}
                        </div>
                      </>
                    );
                  })()}
                </div>

                {/* Footer - positioned at bottom */}
                <div style={{
                  position: 'absolute',
                  bottom: 24,
                  left: 32,
                  right: 32,
                  textAlign: 'center',
                  borderTop: '1px solid rgba(255,255,255,0.15)',
                  paddingTop: 10,
                }}>
                  <ShareCardFooter />
                </div>
              </div>
            </div>

            <div className="flex justify-end mb-2">
              <button
                onClick={shareResults}
                disabled={shareStatus === 'generating'}
                className={`text-sm px-3 py-1 rounded-lg transition-colors flex items-center gap-1 ${
                  shareStatus && shareStatus !== 'generating'
                    ? 'bg-green-900/50 text-green-400'
                    : 'bg-slate-700/50 hover:bg-slate-600/50 text-red-200'
                }`}
              >
                {!shareStatus && (
                  <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z" />
                  </svg>
                )}
                {getShareButtonText()}
              </button>
            </div>

            <div className="text-center mb-4">
              <div className={`text-6xl inline-block ${monsters[winner].color.glow} monster-glow float`}>
                {monsters[winner].emoji}
              </div>
              <h2 className="text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 to-orange-400 mt-2">
                Victory!
              </h2>
              <p className="text-red-200 mt-1">
                <span className="font-semibold">"{choices[winner]}"</span> wins!
              </p>
            </div>

            {/* Analysis */}
            {(() => {
              const analysis = getAnalysis();
              if (!analysis) return (
                <div className="bg-slate-700/50 rounded-xl p-4 mb-4">
                  <p className="text-red-200/80 text-center text-sm">
                    You didn't use any items. Try dragging potions onto monsters next time to reveal your preference!
                  </p>
                </div>
              );

              return (
                <div className="bg-gradient-to-br from-purple-900/50 to-indigo-900/50 rounded-xl p-4 mb-4 border border-purple-500/30">
                  <h3 className="text-purple-300 font-semibold text-center mb-3">
                    What Your Heart Revealed
                  </h3>

                  <div className="flex justify-center gap-6 mb-3">
                    <div className="text-center">
                      <div className={`text-3xl ${monsters[0].color.glow} monster-glow`}>{monsters[0].emoji}</div>
                      <p className="text-purple-200 font-bold text-lg">{analysis.helpfulCounts[0]}</p>
                      <p className="text-purple-300/60 text-xs">helpful items</p>
                    </div>
                    <div className="text-center">
                      <div className={`text-3xl ${monsters[1].color.glow} monster-glow`}>{monsters[1].emoji}</div>
                      <p className="text-purple-200 font-bold text-lg">{analysis.helpfulCounts[1]}</p>
                      <p className="text-purple-300/60 text-xs">helpful items</p>
                    </div>
                  </div>

                  {analysis.isTie ? (
                    <p className="text-purple-200 text-center text-sm">
                      You helped both equally. You're genuinely torn between these options!
                    </p>
                  ) : (
                    <div className="text-center">
                      <p className="text-purple-100 font-medium">
                        You favored <span className="text-yellow-300">"{analysis.favoredChoice}"</span>
                      </p>
                      <p className="text-purple-200 text-sm">
                        ({analysis.favoredPercent}% of helpful items)
                      </p>
                      <p className="text-purple-300/80 text-sm mt-2">
                        {analysis.favoredPercent >= 75
                          ? "Your instincts strongly pulled you toward this choice. Trust that feeling!"
                          : analysis.favoredPercent >= 60
                          ? "You showed a clear preference. Worth exploring why."
                          : "A slight lean ‚Äî you seem fairly balanced between the two."}
                      </p>

                      {analysis.favoredIndex !== winner && (
                        <p className="text-amber-300/80 text-sm mt-3 italic">
                          Interesting... you helped the loser more. Sometimes we protect what we secretly want to win.
                        </p>
                      )}
                    </div>
                  )}
                </div>
              );
            })()}

            <div className="flex gap-3">
              <button
                onClick={() => {
                  // Replay with same choices
                  setReplayCount(prev => prev + 1);
                  const currentChoices = [...choices];
                  setMonsters([generateMonster(currentChoices[0], 0), generateMonster(currentChoices[1], 1)]);
                  setBattleLog([]);
                  setItemsUsed([[], []]);
                  setActiveEffects([[], []]);
                  setRound(0);
                  setAttackingMonster(null);
                  setHitMonster(null);
                  setWinner(null);
                  setBoostEffect([false, false]);
                  setItems([]);
                  setShowConfetti(false);
                  setIsCritical(false);
                  setScreenShake(false);
                  setCritAttacker(null);
                  setDamageText(null);
                  setStage('intro');
                }}
                className="flex-1 py-3 bg-slate-700/50 hover:bg-slate-600/50 text-red-200 font-bold rounded-xl transition-all border border-red-500/30"
              >
                üîÑ Replay
              </button>
              <button
                onClick={reset}
                className="flex-1 py-3 bg-gradient-to-r from-red-600 to-orange-600 hover:from-red-500 hover:to-orange-500 text-white font-bold rounded-xl transition-all"
              >
                New Battle
              </button>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
